#+TITLE: Notes
#+OPTIONS: toc:2
#+OPTIONS: num:nil
#+OPTIONS: broken-links:nil
#+OPTIONS: prop:nil d:t

#+HTML_HEAD: <style>pre.src{background:slategray ;color:white;} body{width:90%; margin:2% auto} @media screen and (min-width:910px) {body{width:900px}}</style>
#+HTML_DOCTYPE: html5

* C++                                                                   :cpp:
** Back to Basics: Move Semantics (part 1)
   :SOURCE:
   :Author: Klaus Iglberger
   :Source: https://www.youtube.com/watch?v=St0MNEU5b0o
   :END:
*** Lvalues and Rvalues
 Lvalues have a name, there is an identifier that the programmer provides to represent the object.
 Rvalues don't have a name.
 It used to be rvalues only appeared on the right side of an assignment (thus right values) 
 (though lvalues could be on both sides) but that's no longer true.
 #+BEGIN_SRC c++
 int i = 3 + 2; // i is an lvalue and '3+2' is an rvalue
 int x = i; // both x and i are lvalues
 #+END_SRC
 =v2 = v1= is a copy since 'v1' is a lvalue and so binds to a reference.
 Rvalue references were added to distinguish between lvalues and rvalues in function arguments 
 [maybe elsewhere too, not sure] and are signified by =&&= (as in =vector<int>&&=).
 Rvalues will bind to rvalue references which is why rvalue references are the 
 arguments of move operations.

 =std::move= itself doesn't actually move anything it just unconditionally casts an lvalue 
 to an rvalue reference (technically called an Xvalue (expiring value)).
 This will cause a move operation to be used.

*** Move Operations
 If all member variables of a class have move operations defined (or are POD) then allow the 
 compiler to generate the move operations of the class.
 The move operations need to be defined if there are resources to be managed.
 **Remember the rvalue reference passed into a move operator is itself an lvalue.**
 #+BEGIN_SRC c++
 MyClass& operator=(MyClass&& c) {
     // c is an lvalue (it has a name)
     this->member = c.member; // so this would be a copy
     // so should do
     this->member = std::move(c.member);
 }
 #+END_SRC

 When defining move operations make sure to explicitly move all the members that need it.
 The easiest thing to do is just call =std::move= on all members variables.
 This won't affect fundamental types (it will still do the copy) but it keeps everything 
 looking the same and nothing will be accidentally missed.

 A move constructor has two phases:
   1) Member-wise move
   2) Reset the source object (setting pointer to null). Otherwise the two objects would free the
      same memory when destroyed.
 If only 1) is present then the default move constructor can be used.

 A move assignment operator has three phases: 
   1) Cleanup original resources in the destination object. This duplicates the destructor.
   2) Member-wise move.
   3) Reset the source object (setting pointers to null).
 If 2) is the only step present then the default move assignment operator can be used.

 =std::exchange= can set the a pointer and return the original value (to make the reset step 
 easier).

 *Mark move operations noexcept.*
 This can lead to performance improvements.
 Move operations should leave the source object in valid but undefined 
 (though preferably default) state.

*** Default Move Ops
 Default move ops are generated if no copy operations or the destructor are user defined.
 Default copy ops are generated if no move operations are user-defined.
 "User-defined" includes setting ==default= and ==delete=.
 Don't define any of the default operations if you don't need to (Rule of Zero).
 If you define any of the default operations (destructor, move constructor, move assignment, copy constructor, copy assignment) define all of the them (Rule of Five).
** Back to Basics: Move Semantics (part 2)
   :SOURCE:
   :Author: Klaus Iglberger
   :Source: https://www.youtube.com/watch?v=pIzaZbKUw2s
   :END:
An rvalue reference is a forwarding reference if it is involved in type deduction or appears 
in the form =T&&= when part of a function template.
This is not the case for class template parameters.
Forwarding references will represent lvalue references if initialized with an lvalue or an 
rvalue reference if initialized with an rvalue.

Passing an lvalue to the following function results in =T= referring to a lvalue reference 
which results in =T& &&=.
*Reference collapsing* makes it =T&=.
But passing it an rvalue makes it =T&&=.
#+BEGIN_SRC cpp
template <class T>
foo(T&& t)
#+END_SRC

*Perfect Forwarding* forwards arguments without copying them.
An example is =make_unique= passing arguments to create a =unique_ptr=.
A forwarding reference will accept anything.

=std::forward= casts rvalues to rvalue references and lvalues to lvalue references.
The type gets provided as a template parameter and used for the cast decision.
=std::forward= makes use of reference collapsing for its behaviour.

=std::move= actually takes a forwarding reference.

An overloaded function that takes a forwarding reference will always be called unless 
another overloaded function matches the given arguments exactly.

=const T&&= is an rvalue reference, not a forwarding reference.

Don't return with a =std::move=, this will break return value optimization (RVO) (copy elision).
Not naming the value being returned (making it an rvalue) guarantees RVO even if there is no 
copy or move constructor.
The compiler will fall back to moving if RVO doesn't work.

Don't return an rvalue reference.

Be careful to remove references from forward references when doing checking the type using 
=remove_reference_t=.
For example checking if the given type is integral using =is_integral_v= will always be false when 
given an lvalue reference.
** API Design for C++
   :SOURCE:
   :Author:   Martin Reddy
   :Publisher: Morgan Kaufmann
   :Date: 2011
   :END:
 #+TOC: headlines 1 :target "API Design for C++"
*** Chapter 2: Qualities
 Always declare data members private as it makes it possible to do processing before changing values (bounds checking, etc.).
 Even if you're not doing anything fancy now, adding it later won't break the API if you already have getters and setters.

 Only include what is necessary.

 In function parameters prefer enums to a booleans.
 Avoid multiple arguments of the same type (create new types for each instead).

 Orthogonal can mean functions don't have side effects on other parameters.
 Or it can mean all operations can be applied to all data types (like the STL algorithms work with all STL containers).

 Never put platform specific =#ifdef= code in the header (hide it in the implementation, maybe add a function for a user to query functionality).

 Prefer non-member functions to reduce coupling.
 This forces the function to only use the class' public API so is less likely to break with implementation changes.

 Providing data to be passed with a callback is apparently a closure.
*** Chapter 3: Patterns
 PIMPL idiom hides impl details by putting them in another class (the impl class).
 The impl class is forward declared in the header and then just a pointer to it is used
 (opaque pointer).
 The problem with a default copy constructor is it does a shallow clone so the copied objects
 will have opaque pointers to the same impl object.
 You can either delete or specify custom copy functions.
 In the case that you actually want copies to share the impl then use a =shared_ptr= to 
 avoid the impl being deleted twice (by the copy and by the original).

 Dependency injection involves passing an object into a class rather than having the class create
 and store the object itself.
 This saves the class needing to know the details needed to initialize the dependency object.
 It provides an alternative to a singleton because the passed object could be global but it is
 easier to test because the object can be mocked.
 The class could be created by a factory which maintains a constructed dependency object to pass in.

 If a class has virtual methods always declare the destructor as virtual.
 If it is not declared virtual and the inheriting class is assigned to a base class pointer before
 being destroyed then the base class' destructor will be called (rather than the inheriting class').
*** Chapter 4: Styles
 Functional requirements specify how the API should behave.
 It doesn't include operation constraints (performance, security, usability, etc.) 
 (non-functional requirements).
 Write each requirement in a versioned document with a specific description and rational.

 Gather use cases: high level actions a user would take.
 These are similar to user stories in Agile: "As a [role] I want [something] so that [benefit]."

 API architecture should be designed to anticipate changes in requirements that are likely
 in the future.

 Once constraints and requirements are analysed, create the key objects and how they fit together.
 These are the major abstractions of the system.
 Deciding key objects can be done in several ways though the results of all these methods should be
 analysed and refined:
 - *Natural language*: Based on how you talk about the problem.
   - Nouns become objects.
   - Verbs become functions.
   - Adjectives become properties.
 - *Properties*: Group objects with similar properties or qualities. These can be discrete 
   (eg. red/blue) or fuzzy (eg. genres).
 - *Behaviours*: Determine the behaviours of the system and assign them to different parts.
   Group objects on their shared behaviours.
 - *Domains (Schlaer-Mellor)*: Split the system vertically into generic domains.
   Then split each of those domains.

 *Friends in classes are normally a sign of bad design.*

 More than 2 or 3 levels of inheritance is getting too complex.
 Avoid multiple inheritance except for inheriting from interfaces.

 "The Liskov Substitution Principle states it should always be possible to substitute a base class 
 for a derived class without any change in behaviour."

 Private inheritance makes public methods of a base class private members of the derived class.
 It's useful to inherit functionality without inheriting the interface.
 Base functions can then be exposed with =using Base::Function;=.

 Composition is when functionality is inherited by having an object as a member rather than 
 through private inheritance.
 It should be preferred over inheritance because it results in a less coupled design.
 Also it supports using an opaque pointer.

 The Law of Demeter says to only call functions from within your class; so member functions or
 member functions of member variables.
 Don't call functions on an object you had to call a function to access.
 This produces loosely coupled designs.

 Rather than having many optional function parameters pass a POD struct.
 This allows extending options without changing the API.

 *Named Parameter Idiom*: Return =*this= from a member function to allow calls to be chained.
 An example where all member variables are set by setters would look like:
 #+BEGIN_SRC c++
 QTimer timer = QTimer().setInterval(1000).setSingleShot(true).start();
 #+END_SRC

 An API should fail quickly when it hits an error and clean up all resources on the way out.
 Try not to return exceptional values (like =nullptr=) since this makes clients write more code 
 to check for it.
 Make sure error codes are an accurate representation of the error.
 If no error codes exactly match the error then add a new one.

 Data driven APIs behave differently based on the input data.
 It allows for changing the program's behaviour by changing the data, which could be created
 by a separate program (by non-C++ programmers).
 It makes it easy to add features without breaking the API.
 It has no compile time type checking and has runtime performance costs.
 It is very dependent on documentation because the header file won't reveal the possible
 actions.
 An example is a single command function that takes the action to execute as a string.
*** Chapter 6: C++ Usage
 When a destructor is needed to cleanup resources a copy constructor and assignment operator are
 probably needed to handle those resources correctly.

 The compiler generated copy constructor does a shallow copy (pointers are copied rather than the
 object they are pointing to).
 The copy constructor is called when an object is:
 - constructed from another
 - passed or returned by value
 - placed in an initializer list
 - thrown or caught as an exception

 Assignment operator guidelines:
 - destroy existing state before setting the new state
 - check for self-assignment (=a = a=)
 - use a constant reference for the right hand operand
 - return =*this= as a reference, for operator chaining

 Marking the copy constructor =explicit= will prevent implicit copies like pass/return by value.
 This is the same for the conversion operators.

 Only =const= methods can be called on =const= objects.
 Declaring a variable =mutable= allows it to be mutated by a =const= method.
 This is useful for changing internal state that is undetectable to a user (eg. update a cache).

 Don't inline the implementation of templates.
 Put the implementation in a "private" header that is included into the main public header.
 It keeps the public header cleaner.

 Templates can be explicitly instantiated for specific types in a .cpp file.
 The implementation can then live in the .cpp file.
 Then add typedefs to the header so a user knows which types they can use.
 This results in faster build times and is useful if you only want to use the template with specific
 types.

 =extern template class Class<type>= will not instantiate the template.
 Good for preventing the compiler from instantiating the same template multiple times.

 The following operators must be class members: ===, =[]=, =->=, =->*=, =()=, =(T)= (C-style cast),
  =new=, =delete=.
 Always prefer to define the remaining operators as free style functions since it:
 - means operands can be on the left and right
 - reduces coupling (operator can't access private members)
 The exception is if the operator needs private access (don't make it a friend instead).

 The C-style cast operator looks like 
 #+BEGIN_SRC C++
 T1::operator T2()
 // for example to convert to a C-style string:
 MyString::operator const char*();
 #+END_SRC
 There's no return value, the compiler gets it from the function name.

 Don't use macros in public headers because they have no typing, no scope and no access control.
 They don't add to the symbol table so you'll just see value in the debugger with no identifier.

 Prevent symbols from having external linkage by enclosing them in an anonymous namespace.
 This stops you from accessing global functions/variables from other namespaces using =extern=.
 Similar to what =static= does.
*** Chapter 7: Performance
 Consider adding "redundant include guards" around =#include= statements to speed up compilation.
 They will prevent the opening and processing of header files that have already been read.
 It can have a significant impact for large files that include lots of files.

 Having a constant variable in a header will cause it to be allocated everywhere it is included.
 The compiler will only inline built-in types.
 Either define constants as =extern= and have the value in a .cpp file or make them static members
 of a class (with the values in the .cpp).
 Or use =constexpr=.
 =constexpr= functions allow for hiding the constant value in the implementation but it still 
 can be used at compile time.

 Initialization lists can avoid calling the default constructors of member variables.

 The compiler will align everything to word boundaries using padding if needed.
 Group member variables by type, this makes it less likely to waste space with padding bytes.

 Bitfields specify how many bits a member variable should occupy.
 There is likely to be a performance cost if this is not a multiple of 8.

 Only add virtual methods when needed since they will add a vtable pointer to the object.

 Copy on write (CoW) is a method to share memory between objects when possible.
 When making a copy of an object keep sharing the internal state until a change is made.
 At that point make a copy and make the change to the copy.
 [Book has an implementation of a CoW pointer.
 Dereferences to const objects don't cause copying but any action which could mutate what it is 
 pointing to causes a copy to be made.
 It uses a =shared_ptr= so it can check if it is the only one pointing to the object (in which 
 case it doesn't need to do a copy.)]
 Apparently most =std::string= implementations use CoW.
 [Seems like it just results in heap allocations happening at unexpected times (on value change 
 rather than when what looks like the copy). 
 I feel like all the benefits could be had more transparently with a bit of effort from the user.]

 Prefer pre-increment for iterators to avoid the construction and destruction 
 of temporaries, apparently.

 As an alternative to iterators, pass an array by reference into a function to be populated with 
 the requested elements.
 It can be useful for linked list/tree like structures since the elements will be copied into 
 contiguous memory making the iteration faster.
 It may only make sense if the results get used multiple times.
 The advantage over iterators is that it can return any selection in any order (rather than 
 sequential start to finish).

 Setting the =MALLOC_CHECK= environment variable enables an alternative allocator in GCC that is 
 more resilient to memory errors (like double frees and single byte buffer overruns).
 It can be useful for debugging memory problems.

 Helgrind & DRD are part of Valgrind and detect synchronization errors in P-thread based 
 applications.

*** Chapter 8: Versioning
 It is useful to make the API version available at compile time (as well as at runtime).
 A Version class with all static member functions can be useful to return the version number 
 information (functions could be =constexpr= to make it available at compile time).
 It can have =IsAtLeast= and =HasFeature= methods to check the API.

 *Source compatibility:* the user can compile their code against a later API without making any
 changes.

 *Binary compatibility:* users only have to relink to use the new API.
 The PIMPL idiom can help since the implementation is hidden.
 Binary compatible changes in C++ include:
 - Adding new classes and non-virtual methods
 - Adding new static member variables
 - Removing private static member variables (if they aren't referenced from an inline method)
 - Removing non-virtual private methods (if they aren't called from an inline method)
 - Changing implementation of inline method (though recompilation is needed to get new implementation)
 - Changing a method's default arguments (recompilation needed to use the new defaults)
 - Adding/removing friend declarations
 - Appending new enumerations to an existing enum
 - Using unclaimed remaining bits in a bit field

 Adding functionality is normally fine for backwards compatibility. 
 Exception are pure virtual functions since implementations will be forced to change.
 When adding parameters you can add default values to maintain source compatibility.
 When adding to a C API you can add new differently named functions and then refactor the 
 implementation of the old one to call the new function.
 An =EnableFeature= method can be added to the Version class from earlier to allow users to
 opt in to new behaviour.

 Forwards compatibility means users can downgrade the API without having to make changes.
 Data-driven style APIs are forwards compatible.
 You could try to add parameters early and then mark them as unused to achieve forwards 
 compatibility.

 Most compilers have a deprecated attribute that can be used to mark things deprecated.
 You can remove functionality after it's been deprecated for at least one release.

 "If you add one new feature for ten clients then each client gets nine features they didn't 
 ask for and you support ten you didn't design for."
*** Chapter 9: Documentation
 It's a good idea to write the skeleton of high-level docs and examples early to force you to 
 think deeply about the API from the user's perspective.

 Suggestions for documentation usability:
 - Have an index page
 - Consistent look and feel
 - Code examples: helps users find the information they need and how to use it in their own code
 - Diagrams
 - Search functionality
 - Breadcrumbs: navigation aids to help user keep track of their location
 - Terminology: terminology should be defined and used consistently.

 Doxygen has =\pre= and =\post= tags to document pre and post conditions.
*** Chapter 10: Testing
 Performance tests can overwhelm you with data (for every test on every machine).
 It's best to treat it as a data mining problem: collect all the data then do a database search
 for the 5-10 worst cases.
 graphs.mozilla.org was a great example.

 Qualities of a good test are:
 - Fast
 - Stable
 - Portable (takes into account things like floating point rounding on different hardware)
 - High coding standards
 - Reproducible failures (should be easy for an engineer to investigate a failure)

 What to target through unit tests:
 - Conditions: test all paths by exercising all combinations of =if=/=else=, =for=, =while=, 
   =switch= statements
 - Equivalence classes: find categories of input that produce different behaviours (eg. below 
   range, in range and above range)
 - Boundary conditions: aiming for off-by-one style errors
 - Parameter testing: all combinations of parameters that alter behaviour
 - Return value assertion: returns correct results for different combinations of input
 - Getters/Setters: calling the getter first should return a sensible default. Then check the 
   setter works.
 - Operation order: try actions in different orders to catch undocumented side effects
 - Regression test: check backwards compatibility. Can use old data files where relevant.
 - Negative testing: check it fails when it is expected to
 - Buffer overruns
 - Memory ownership: check that the API owns or releases ownership of memory when it claims to.
   You can rerun functions to make sure the returned pointers are different each time.
   Try freeing returned memory then rerunning to make sure there's no corruption or crash.
 - NULL input: check all functions that accept pointers handle =NULL=

 Focus on tests that:
 - exercise the primary workflow
 - offer the widest code coverage
 - test the most complex code
 - target parts of the design that are poorly defined
 - test features with the highest performance/security concern
 - test for problems that cause the worst client impact
 - test features that can be complete early on in the development cycle

 In TDD when they say write only the code to get the test working they mean it (eg. by just 
 returning a constant).
 Idea is you build up the tests until it covers all the desired behaviour.
 It makes you think from the users perspective.

 *Only use assertions to catch programming errors that should never happen.*
 Assert pre- & post- conditions.

 Stub & Mock objects can make tests easier to write.
 Fake objects have the same functional behaviour but with a simpler more testable implementation 
 (eg. using an in memory filesystem).

 Stub objects have the same interface but are loaded with predictable results.

 Mock objects are like stubs but have include instrumentation to verify the function calls 
 (number of calls, what was returned, what arguments, etc.).

 These all can be used with dependency injection or by linking against the mock/stub instead of 
 the real implementation.

 Mock and stub objects are normally created by inheriting from the real implementation.

 A proxy object can be used to add logging/profiling to API functions to avoid muddying the actual 
 API.

 Record & Playback: Idea of having functions log their arguments and return values.
 Then you can have a playback module that can read the log, call functions and check the results.
 Tests get stored as data

 Gcov is a code coverage tool that's part of GCC.
 Suggests different code coverage targets depending on how code coverage is measured: 
 100% by function, 90% by line or 70% by condition coverage.
*** Chapter 12: Extensibility
 /Never inherit from a class without a virtual destructor./

 STL streams are designed to be inherited from.
 Boost iostreams has things like filters and compression.

 Explicitly prevent people from inheriting from a class by making the constructors private and use a Factory method instead.
 This prevents it from being constructed on the stack.

 An alternative is to use virtual inheritance, which will work on the stack:
 #+BEGIN_src c++
 class NonBase;

 class NonBaseFinal {
 private:
   NonBaseFinal(){}
   friend class NonBase;
 };

 class NonBase: virtual public NonBaseFinal {
 public: 
 ...
 };
 #+END_src

 *Policy-Based Templates*: create a class template that accepts several template parameters (policies) 
 that affect the behaviour of the class. eg.
 #+BEGIN_SRC c++
 template<
   typename T,
   template<class> class OwnershipPolicy = RefCounted,
   class ConversionPolicy = DisallowConversions
 > class SmartPtr
 #+END_SRC
 T is the type the smart pointer will point to, the others are policies.

 *The Curiously Recurring Template Pattern:* has a class that inherits from a templated base class with 
 the derived class as the template parameter.
 It provides compile time polymorphism.
 The base class can access members from the derived class by casting =this= to the derived class's type (which 
 it knows because it was provided as the template parameter).
 #+BEGIN_SRC c++
 template <class T> class Base;

 class Derived : public Base<Derived>;
 #+END_SRC

** STL Algorithms - Why You Should Use Them, and How to Write Your Own
   :SOURCE:
   :Author:   Marshall Clow
   :Source:   https://www.youtube.com/watch?v=h4Jl1fk3MkQ
   :END:

Boost algorithms and the Adobe algorithms library are useful collections of algorithms.

The STL implementations often try to minimize the requirements on the processed types
(eg. will use =<= and ==== rather than =>==).

It's easy to write your own algorithms:
- Give them a good name
- Take the range as iterators marking the beginning and end
- Handle degenerate cases (empty containers (=begin() == end()=), only 1 element, etc.)
- They should be general but not necessarily universal so it's OK for them to make
  certain requirements of the types
- The STL algorithms can be used as building blocks
  - Many problems can be implemented simply (and more efficiently) with the existing algorithms
- Worry about complexity
- Consider the iterator category (input, forward, random access ...)
  - It can have a big influence in how the algorithm is implemented.


=iterator_traits= can be used to get information about the iterator you've been passed
(including the type it points to).
=iterator_category= says what type of iterator it is, which can then be used for
specializations (where the specialized function takes an object for the iterator type).
#+BEGIN_SRC cpp
  template <typename FWIter, typename Func>
  void adjacent_impl(FWIter first, FWIter last, Func f, std::forward_iterator_tag);

  template <typename Iterator, typename Func>
  void adjacent(Iterator first, Iterator last, Func f) {
       return adjacent_impl(first, last, f, typename std::iterator_traits<Iterator>::iterator_category());
  }
#+END_SRC
This is what the standard library does a lot.

** Object-Oriented Program: Best Practices
   :SOURCE:
   :Author:   Jon Kalb
   :Source:   https://www.youtube.com/watch?v=c0lutJECNUA
   :END:
 Object orientation provides a separation of concerns.
 The base class designs the API and the children implement it.

 Liskov substitution: if type D has all the properties of type B then it is a proper sub-type and
 any code designed to work with B will also work with D.
 Should always aim to create proper sub-types.

 Derived and base classes each have a v-table pointer.
 Since the base class has one it makes it accessible from a base class pointer.
 The V-table has a list of function pointers (one for each virtual/overridden function).

 Inheritance often gets treated as a way to reuse code.
 This results in a mess.
 It should instead be thought of as a problem-solving method.
 The base class decides on the functionality and the derived class "is-a" instance of the base
 class functionality.
 Example: =ConsoleLogger= "is-a" =Logger= while =StatusDisplayer= is not a =Logger= (even though 
 it may use similar code).
 *Make sure public inheritance models "is-a".*

 Only dereference an OOP pointer to access base class members.
 This can be enforced by only deriving from abstract classes.
 It means base classes have a single responsibility: to be a base.
 All concrete class get maintained independently, which makes code more maintainable.
 Then make the assignment operators protected on the base classes but public on the 
 derived classes.

 Function overloading only works inside the same scope (not between a base and derived class).

 Don't specify default values in function overrides since it won't actually apply when calling
  from a pointer to the base class.

 Don't call virtual functions from the constructor and the destructor.

 Try to avoid casting by writing code that works with all the derived classes (even if some 
 don't actually do anything with the calls).
 So you don't have to cast to D to call a function that only D has if all the other derived
 classes also have that function (but in their cases it might be empty).
** The C++ ABI From the Ground Up
   :SOURCE:
   :Author:   Louis Dionne
   :Source:   https://www.youtube.com/watch?v=DZ93lP1I7wU
   :END:
   The ABI can be thought of as being like the API but for machine
   code.

   =itanium-cxx-abi= is on GitHub and is the standard for the Itanium C++ ABI.
   It affects things like
   - how arguments are passed to functions (it's the same as C for
     trivial types)
   - how base classes are layed out (whether the inherited sections
     are placed before or after in a derived class)
   - name mangling
   - vtable layout
   - RTTI layout
   - exception handling

   The type of a lambda can't be in a function signature because then
   it will need to be mangled to make it uniquely identifiable from
   other lambdas, which would mean mangling based on the body of the
   lambda.

   Simple changes that make a struct trivial or not will break ABI
   (because it would be passed on the stack vs. the heap).

   Safe changes that won't break ABI:
   - add new non-virtual functions
   - add an enum to a class
   - add new enumerators to an existing enum
     - make sure the underlying type doesn't change
   - define inline functions out of line
     - it must be OK for programs to call the old version
   - add new static data members
   - add new classes
   - add/remove friend declarations

   The ABI can be controlled using inline namespaces, which are not
   part of the API but contribute to name mangling. It can be changed
   when breaking the ABI and the API will stay the same but the linker
   will see the change.

   Symbol visibility can hide symbols from the ABI surface.

   Linkage is like visibility but for static libraries. Specify
   internal linkage so the function will be local to the translation
   unit.

   Vtable and RTTI visibility can be controlled with the visibility
   attribute.

   =nm -gmU= will list exported symbols nicely.

   =c++filt= demangles names (=nm= can be piped in).

   =abidiff= (from libabigail) gives a human readable differences
   between ABIs, which could be used as part of CI.
** 105 STL Algorithms in Less Than An Hour
   :SOURCE:
   :Author:   Jonathan Boccara
   :Source:   https://www.youtube.com/watch?v=bXkWuUe9V2I   
   :END:
 Make code simpler and more expressive
 N.B.: '_*' means can be applied to different functions 
*** Heaps
  - heap is a tree where the parent is larger than the children
    - can be represented (and stored) as an array/vector
  - =make_heap=: takes a collection and creates a heap
  - =push_heap=: add and bubble object to correct place
*** Sort
  - basic one is =sort=
  - =partial_sort=: takes iterators and sorts part of collection
  - =nth_element=: pass iterator to position in collection and the element that would go in that place if the collection is sorted is moved to it
    - elements below will be unsorted but smaller than the sorted element and vice versa
  - =inplace_merge=: takes collection where 2 parts sorted and makes whole thing sorted
  - =std::partition=: takes predicate and put all that match at the beginning
  - =partition_point=: fetches the partition point (point between matching & unmatching section)
  - =rotate=: element at end goes to the beginning
  - =shuffle=: guess!
  - =reverse=
  - =stable_*=: can be applied to other functions. Means relative order won't change after transformation
  - =is_*=: checks whether collection is whatever the function does (eg. is_sorted returns true if sorted)
  - =is_until_*=: like =is= but takes iterator and checks until that iterator
  - =count=
  - =accumulate=: applies operation to collection and returns the result.
  - =reduce=: like accumulate but has overload that doesn't take an initial value and can be parallelized
  - =transform_reduce=: applies function to values of collection before calling reduce
  - =partial_sum=: Computes the partial sums of the elements in the given sub-ranges and writes them to the given range.
  - =inclusive_scan=: [[https://en.cppreference.com/w/cpp/algorithm/inclusive_scan][inclusive\under{}scan]]
  - =exclusive_scan=: [[https://en.cppreference.com/w/cpp/algorithm/exclusive_scan][exclusive_scan]]
  - =adjacent_difference=: Computes the differences between the second and the first of each adjacent pair of elements in a range.
    - =sample=: picks random elements from collection
*** Query Property
 - =all_of=: takes collection and predicate and returns if all elements satisfy predicate
   - passing empty collection results in false
 - =any_of=: if any satisfy the predicate
   - passing empty collection results in true
 - =none_of=: if none satisfy the predicate
   - passing empty collection results in true
 - =equal=: takes two collections and check if all elements are equal, same order and the collections are the same length (bool)
 - =is_permutation=: if some contents but not necessarily same order (bool)
 - =lexicographical_compare=: which is smaller
 - =mismatch=: returns pair of iterators for where the two collections start to differ
*** Unsorted Search
 - =find=: search for value in unsorted container
 - =adjacent_find=: searches for two consecutive occurrences of value in unsorted container
*** Sorted Search
 - =equal_range=: returns range of collection where all the searched for values are
   - may be an empty range if no occurrences of value in the collection
 - =lower_bound= & =upper_bound=: position to place value on either side of the range returned by equal_range [33:44 for example]
   - =lower_bound= doesn't return end() if the value isn't in the collection
 - =binary_search=: does binary search and returns true if the value exists.
*** Search a Range
 - =search=: looks for sub-range inside a range and gives first occurrence
 - =find_end=: gives the last occurrence of sub-range in range
 - =find_first_of=: find first occurrence of any of the values in the sub-range in the collection.
*** Searing a Relative Value
 - =max_element=: returns iterator to the biggest element in the collection
 - =min_element=: same as =max_element= but with smallest element
 - =minmax_element=: gets both biggest and smallest elements as iterator pair
*** Sets
 - sets are sorted collections
 - =set_difference=: get the elements that are in one set but not in the other (linear complexity)
 - =set_union=, =set_intersection=: includes [37:00]
 - =set_merge=, =set_symmetric_difference=
*** Movers
 - =copy=: copy every element in input range to output
 - =move=: moves every element to new collection
 - =swap_ranges=: swap two ranges that have the same size
 - =copy_backward=: like copy but starts at the end of the range
 - =move_backward=: like previous but for move
*** Value Modifiers
 - =fill=: takes collection and value and sets all elements to the value
 - =generate=: like fill but takes a function to call for each element to get the value for that element
 - =iota=: fills collection with incrementing elements starting with given value
 - =replace=: replaces every occurrence of value with another
*** Structure Changers
 - =remove=: gets called with collection and value to remove. Since it only has access to iterators it can't actually delete the elements and instead shifts all the matching elements to the end of the collection and returns the start of that section. The value of those elements is now unknown. Use =erase= to actually delete the elements.
 - =unique=: removes adjacent duplicates (works the same way as =remove=)
 - =*_copy=: combined with other algorithms. Does same as algorithm but outputs result somewhere else.
 - =*_if=: takes predicate
 - =transform=: applies function to every element of a collection. Takes an output iterator.
   - Overload takes two collections and function that takes two parameters. Result of each function call are outputted to the output iterator.
 - =for_each=: calls function for every element on collection and doesn't care about the return value [For functions with side effects]
*** Raw Memory
 - =uninitialized_*=: work with =fill_copy=, and =move= to have them work on uninitialized memory. To work with raw memory.
 - =destroy=: calls destructor for every element.
 - =*_n=: does the algorithm but takes a size and only does that many steps
** Back to Basics: Understanding Value Categories
   :SOURCE:
   :Author: Ben Saks
   :Source: https://www.youtube.com/watch?v=XS2JddPq7GQ
   :END:
Originally an lvalue was an expression that referred to an object that had storage.
And an rvalue wasn't an lvalue.

When an lvalue is used in the place of an rvalue an lvalue-to-rvalue-conversion occurs as the compiler only cares
about the value the object has rather than the storage.

Rvalues of class types occupy storage so that they can access members.

#+ATTR_HTML: :rules all :frame border
|                                 | *can take the address of* | *can assign to* |
| *lvalue*                        | yes                       | yes             |
| *non-modifiable lvalue (const)* | yes                       | no              |
| *(non-class) rvalue*            | no                        | no              |

References work like const pointers.
References yield lvalues.

Creating a reference to const of type =T= with an expression that is not of type =T= will create 
a temporary =T= and then get the reference of that.
The temporary lives for as long as the reference does.

Temporary materialization conversion: converts an prvalue to an xvalue.
It happens in the case of the reference to const example.

C++11 added rvalue references. 
They are normally used for function parameters and return values with move semantics.
But =int&& i = 10;= is something you can do since 10 is an rvalue.

If it has a name its an lvalue.

Binding rvalue references to rvalues creates an xvalue.

=std::move= converts lvalues to xvalues (an unnamed rvalue reference).
It's the way to inform the compiler that an lvalue is about to expire.

#+name: value-categories
#+header: :results output graphics file
#+header: :imagemagick yes :headers '("\\usepackage{tikz}")
#+header: :fit yes :iminoptions -density 1000 :imoutoptions -geometry 300
#+BEGIN_SRC latex :file images/value-categories.png
  \usetikzlibrary{arrows,positioning}
  \tikzset{
    >=stealth',
    pil/.style={
      ->,
      thick,
      shorten <=2pt,
      shorten >=2pt,
    }
  }
  \begin{tikzpicture}[node distance=1cm, auto,]
    \node (lvalue) {lvalue};
    \node[right=of lvalue] (xvalue) {xvalue};
    \node[right=of xvalue] (prvalue) {prvalue};
    \node[above=of xvalue] (dummy) {};
    \node[left=of dummy] (glvalue) {glvalue}
    edge[pil] (lvalue)
    edge[pil] (xvalue);
    \node[right=of dummy] (rvalue) {rvalue}
    edge[pil] (xvalue)
    edge[pil] (prvalue);
    \node[above=of dummy] (expression) {expression}
    edge[pil] (rvalue)
    edge[pil] (glvalue);
  \end{tikzpicture}
#+END_SRC
- *glvalue*: generalized value
- *xvalue*: behave like rvalues and lvalues (they occupy storage)
- *prvalue (pure rvalue)*: always behave like rvalue and never occupy storage

** Beginners Guide to Linkers
   :SOURCE:
   :Author:   David Drysdale
   :Source:   https://www.lurklurk.org/linkers/linkers.html
   :END:
 - a definition: associates a name with an implementation (data or code)
 - a declaration: tells the compiler that a definition of somethings exists somewhere
 - What the C Compiler does
   - outputs object files (.o *nix, .obj Windows)
   - object file contains code (function definition) & data (variable definitions)
     - instances have associated names
   - compiler only allows code to reference function/variable if seen declaration for it
     - compiler creates a reference with an associated name. Linker finds the actual value for that name
 - =nm=: information on symbols in object file
   - 'U': undefined reference
   - 't': defined reference (local to file (static))
   - 'T': defined reference (not local to file)
   - 'd': initialized global variable (local)
   - 'D': initialized global variable (not local)
   - 'b': static/local uninitialized global variable
   - 'B'/'C': not local uninitialized global variable
 - Duplicate Symbols
   - C++: must be exactly 1 definition of a symbol
   - C: must be 1 definition of functions and initialized global variables
     - definition of uninitialized global variables can be treated as tentative definition and allows different files to have tentative definitions of same object
   - FORTRAN model has duplicate global variable in each file and linker picks the largest then discards the rest
 - What the OS does
   - Loads the object file into memory
     - machine code into code segment (where reachable by CPU)
     - data (global variables) into data segments
       - initialized variables store value in object file which is also loaded to memory
       - linker assumes initialized variables are 0
 - Static Libraries
   - Windows: static lib has .lib extension same as import library (comes with dll)
   - Linker creates list of unresolved symbols then checks for symbols in objects contained in static lib. If symbol definition is there then copies in entire object.
 - Shared Libraries
   - When linking and finds symbol in shared library, linker marks name of symbol and which library it comes from
     - At runtime, remaining linking happens before main function
     - this is done by ldd.so (smaller version than linker)
   - ldd.so maps entire library into programs address space
     - this is so different processes can share the code segment
 - Windows dll differences:
   - Windows dlls don't export symbols by default (symbol manually specified)
     - symbols exported by:
       - in code =declspec(dllexport)=
       - =/export= option for linker
       - linker pull in module definition (.def) file with an EXPORTS section
   - information about exported symbols not held in dll
     - import library (.LIB) contains exported symbols and locations
     - Windows binaries can specify which symbols to import
     - Unix allows linking against shared library with undefined symbol - exe can then provide symbol
       - Windows doesn't allow this
       - Makes circular dependencies tricky but Windows has special method around it
 - =nm --demangle=: shows unmangled symbols
*** C++ Global Object Construction
 - objects can require code to be run to be initialized (contrast to C, where just value)
 - compiler creates list of constructors for each C++ file that need to be called for global objects
   - linker combines all lists into 1 & add code to call all constructors
   - order of global object construction is undefined
*** Templates
 - Two methods for dealing with templates
   - compiler creates multiple instances of symbols (wherever that template gets used)
     - created as weak references so linker throws away all but 1
   - Machine code gets generated by linker
     - saves space in object file
     - slow link since has to call compiler
     - linker has to track where headers files are
*** Dynamically Loaded Libraries
 - Shared libraries can be loaded at runtime with =dllopen=/=LoadLibrary=
 - Address of symbol got with =dllsym=
 - Interaction with C++
   - =dllsym= takes mangled name so can't be used portably
   - Usually best to have single extern "C" entry point that could be factory for creating C++ class
*** Resources
 - John Levine: Linkers and Loaders
 - Peter Van Der Linden: Expert C Programming
** When the Hot Loop's Done: Four Quick Tips for High Throughput
   :SOURCE:
   :Author:   Herb Sutter
   :Source:   https://herbsutter.com/2020/04/01/when-the-hot-loops-done
   :END:
 - Avoid holding locks or resources
 - Don't acquire locks or resources (and test to avoid freeing resources)
 - Keep all blocking operations outside performance critical sections
 - Don't do IO in hot loops
   - instead defer it by buffering up the side effects using a lock free ring buffer

** Effective CMake
   :SOURCE:
   :Author:   Daniel Pfeifer
   :Source:   https://www.youtube.com/watch?v=bsXLMQ6WgIk&t=4539s
   :END:
 - treat CMake config like code
 - Directories: entry point must contain CMakeLists.txt
   - subdirectories: =add_subdirectory()=
 - Scripts: <script>.cmake can be executed with cmake -P <script>.cmake
 - Modules: <script.cmake> in CMAKE_MODULE_PATH. Can be loaded by include()
 - Scripting commands change state of command processor
 - Variables:
   - are not environment variable
 - comments: # single line
   - #[==[ multi-line comments. number of equals signs is variable which allows nesting of comments
 - Generator expressions: $<> syntax
   - not evaluated by command interpreter
   - evaluated during build system generation
 - Custom commands
   - either function() or macro()
   - Difference like C++
   - when overwrite old function then old access with '_' prefix
   - function:
     - ARGC number of arguments
     - ARV list of arguments
   - Macro have the same variables available except they use text replacement (eg.${ARGC})
   - Create macros to wrap commands that have output parameters
     - because don't know what parent will set in its scope so can get same side effects as wrapped function
 - Deprecating functions
   - wrap function in macro with a deprecation message [12:32] (then run original command)
 - Deprecate variable using =variable_watch= [13:20]
 - Modern CMake about targets and properties
 - prefer to use =add_library= + =target_link_library= multiple times than collect all sources into variables
 - Avoid custom variables in the arguments of project commands
 - Don't use file(GLOB) in projects
   - problem because it evaluates glob to get a list of files and gives that list to the actual build system. Means that the build system won't pick up on new files until cmake is run again.
     - but is useful in scripting
 - Can think of targets a objects
   - =add_executable= and =add_library= like constructors
   - have series of member functions [18:18]
 - Don't use following commands because it's better to act on target level while these act on a directory level:
   - =add_compile_options=, =include_directories=, =link_directories=, =link_libraries=
 - =target_compile_features=: used to specify needed features for target
   - PUBLIC keyword is used for public header
   - PRIVATE for private implementation file
 - Both the build specification (what is required for builds) and usage requirements (what is needed to use) is defined for a target.
   - Non-INTERFACE properties define build
   - INTERFACE properties define usage
   - PRIVATE populates non-INTERFACE property
   - INTERFACE populates INTERFACE property
   - PUBLIC populates both. Because it is valid both for target and other targets linking it
 - INTERFACE libraries have no build specification
   - eg. 
     #+BEGIN_SRC cmake
     add_library(Bar INTERFACE)
     target_compile_definitions(Bar INTERFACE Bar=1)
     #+END_SRC
     - only has usage requirements
     - useful for header only libraries
 - How to use external libraries:
   - library can be found with eg.
     =find_package(FOO 2.0 REQUIRED)=
   - then linked with
     =target_link_libraries(... Foo::Foo ...)= since find_package creates a Foo namespace
   - find_package searches for a find module [31:21]
     - this does the actual searching and importing of library and properties
   - use a find module for libraries that aren't built with CMake
   - CMake allows exporting of library interface for users to use [38:00]
     - involves saving install targets to variable
     - write another file to specify where to find the dependencies of the library which gets installed with the exported file
 - Can create packages with CPack
 - CTest can be used with CMake scripts and is the place to set up CI builds.
   - CTest supports -j switch
 - Follow a naming convention for test names. This simplifies filtering by regex
 - Can have tests that fail to build [1:02]
 - Static analysis
   - clang-tidy
   - include-what-you-use: analyses use of what you've #include
   - dazy: checks for C++ anti-patterns
   - CMake has target properties for listed tools (eg.CXX_CLANG_TIDY), which runs tool with compiler [1:10]
     - initialized with CMAKE_<property>
     - tools may not show warnings for header files with no source file. Solution is to have empty source file which #include header. May be compiler warning.
   - enable static analysis from outside [1:15]

** Naming is Hard: Let's Do Better
   :SOURCE:
   :Author:   Kate Gregory
   :Source:   https://www.youtube.com/watch?v=MBRoCdtZOYg
   :END:
 - Naming is a learned skill.
 - Good names require less comments in code.
 - The wrong names can lie.
 - When refactoring, a method is to use extremely verbose names and then it will become clear what the name should be.
 - =sort= and =partial_sort= are examples of good names.
 - =partial_sort_copy= is an example of a good implementers name but doesn't address the problem that users normally have when they are looking for that function.
   =top_n= would have been a better user name.
 - Always call everything by the same name (don't use a different name for users and developers).
 - Don't invent business words for parts of functions.
 - Prefer single English words over implementation specific words.
 - Don't mismatch natural pairs (begin & end not begin & last)
 - Functions should use verbs with helper verbs if needed (isEmpty() vs. Empty())
 - If you need to use =nodiscard= it means your name confuses people.
 - If similar functions have similar names they will appear together in the IDE auto-complete list.
 - Member function parameters should help the caller.
 - If you are decorating variables to distinguish member variables then decorate members rather than parameters.
 - Classes should be Nouns.
 - Anything with '-er' is suspect without a Noun (what does 'Manager' manage).
 - Try to follow traditions (open/close a file, get/set).
 - Answer the question the calling code is asking: rather than having =getStatus()= followed by a check to see if it is approved just have a function called =isApproved()=.
 - Very small names are fine in a very small scope.
 - If there is only one template typename then =T= is fine.
 - Any more than that then all should have meaningful names.
 - Don't use temporary names because nothing written in the code will make you change it.
    Instead just name things as best as you can and then fix it later.
 - Always fix a name when you understand it.
** Postmodern C++
   :SOURCE:
   :Author: Tony van Eerd
   :Source: https://www.youtube.com/watch?v=Zx_Tjp9WIII
   :END:

When not following a typical pattern leave a comment explaining why not (eg. when using a container 
other than vector).

An API is defined by the calling code more than by the implementation.
How people use it *is* the API.

Give a function only when it needs rather than everything in an object to let it take what it wants.

Flexible formatting can aid with communication.

Spin things into their own functions.
It doesn't have to be used multiple times.

[Quite an entertaining talk, notes don't really cover it.]
** Quickly Testing Legacy C++ Code with Approval Tests
   :SOURCE:
   :Author:   Clare Macrae
   :Source:   https://www.youtube.com/watch?v=3GZHvcdq32s
   :END:
 - Approval tests lock down the current behaviour.
 - Golden master: input data and save the output.
   - while making changes compare the output to master.
 Approvaltests is an implementation of Golden Master testing which runs on many languages.
 It supports GoogleTest, Catch2 and doctest.
 It's header-only.
 The main.cpp needs to define which test framework you're using.
 =Approvals::verify= gets the output of a run.
 ApprovalTests.cpp is the C++ version (.cpp is just part of the project name).
 It manages saving the output to files (named according to the test name).
 It can take sequences with input and then run the test with every combination of those containers.
 It then shows a graphical diff tool on test failure except when running in CI systems (which it automatically detects apparently).
 The reporter can be customized.
 Custom verification functions can be created for results that aren't text or not normal.
 [The example was she wrote a custom comparison function which ignores differences under a threshold for picture outputs.]
** C++ Sanitizers and Fuzzing for the Windows Platform Using New Compilers
   :SOURCE:
   :Author:   Jim Radigan
   :Source:   https://www.youtube.com/watch?v=0EsqxGgYOQU
   :END:
 Pointers and types make static analysis really difficult.
*** Address Sanitizer
 The compiler adds instrumentation code and calls into the runtime.
 The sanitizer runtime adds hooks to allocation functions, which doesn't need a recompile and has zero false positives.
 The address sanitizer should be combined with fuzzing.
 Fuzzing involves running the application with random inputs.
 Code paths can be kept track of while fuzzing to make sure everything runs.
 Windows can create snapshot files that contain all the memory mapping.
 These can be opened in Visual Studio 2019 so the program will be in the exact state it was when it crashed.
 VS ASAN includes an undefined behaviour (UB) sanitizer.
** Small is Beautiful: Techniques to Minimize Memory Footprints
   :SOURCE:
   :Author: Steven Pigeon
   :Source: https://www.youtube.com/watch?v=Dxy66x6v4HE
   :END:
   - Pointers can be compressed
     - Some data structures are pointer rich so large amount of space is used by pointers
     - Computers have much less memory than the theoretical limit that can be addressed by a 64-bit pointer
       - And even less than that is actually used
     - Most CPUs can't use more than a 36-bit address
     - OS gives program blocks of memory
     - [4:00] Template for compressing pointers
       - Takes type and number of bits to use
       - Check if the pointer is closer to the start or end of the memory block and encodes that
       - Then can store the offset from the top or the bottom
     - GCC has functions for getting the actual memory address
   - We often use larger than needed types
     - enum defaults to using ints
     - [has an example of templates that takes the max value and returns the number of bits required to store that and then another that takes the number of bits and returns a type]
     - [has system for finding the smallest number of bits needed for a value. Something involving sub-bitfields]
** C++ Code Smells
   :SOURCE:
   :Author:   Jason Turner
   :Source:   https://www.youtube.com/watch?v=f_tLQl0wLUM
   :END:
   Lots of guidelines have been published.
   The idea of smells is they are indications to help apply the rules from the guidelines.
   - Construction of variable separate from assignment
   - Raw Loops: raw loops don't express intent but algorithms do
   - Multi-step functions: should probably be split into multiple functions
   - Code with implicit constructors
   - =std::move= 
     - =std::move= is a unconditional cast to an rvalue reference
     - return by move prevents move elision
   - Casting away const
   - Static variables generate a check before every access (C++17 says it must be initialized thread safely)
     - =const static= doesn't have that overhead
   - =extern const=: can often just be =constexpr=
   - =std::size()= is a generic function (like begin & end)
   - Kate Gregory recommends making everything =const= because the compiler helps you not changes things you shouldn't
   - don't use =const= on return type as it will result in a copy when assigned to a variable
     - exception is when the assigned to variable is also =const=
   - clang-tidy has check for string -> cstring -> string conversions
   - member variables should not be const?
** Great C++ =is_trivial=
   :SOURCE:
   :Author: Jason Turner
   :Source: https://www.youtube.com/watch?v=ZxWjii99yao
   :END:
RVO doesn't happen when returning structured bindings since they end up pointing to a hidden structure.
In that case it makes sense to return with =std::move=.

=is_trivially_destructible=: default destructor is trivial.
Defining a destructor makes it not trivial.
Having a non-trivially destructible member makes it non-trivially destructible.

=is_trivially_copyable=: needs a non-deleted destructor.
Needs a trivial copy constructor, move constructor, copy assign operator, move assign operator and
destructor.

=is_trivially_constructible=: can't call non-trivial operator during construction.
It takes the type and the arguments that would be passed to the constructor.
A non-default constructor is not trivial.

=is_trivially_default_constructible=: pretty much the default constructor doesn't do anything.
The following isn't trivial default constructible because the compiler generates a constructor 
that sets =i= to 0.
#+BEGIN_SRC cpp
struct S {
  int i{};
};
#+END_SRC
Not so important since it makes initialization so painful.

=is_trivially_copy_constructible=: trivially constructible with itself.
The =S= struct above is trivially copy constructible.

=is_trivially_assignable=: won't call non-trivial operations.

There are load of other =is_trivially_= checks.

=is_trivial=: includes basic types and class types that are trivially constructible and have a default 
constructor that is trivial (and does not have virtual functions).

Out parameters open the door for UB if it captures an uninitialized variable.

=std::array= is trivial if it contains a trivial type.

Things that can't be trivial include:
- anything with a destructor
- runtime polymorphic objects
- anything using the heap (or dealing with resource)

Rule of Zero gives the compiler lots of room to optimize code.

Triviality is important when writing =constexpr= friendly code.

** Rethinking Exceptions
   :SOURCE:
   :Author:   Jason Turner
   :Source:   https://www.youtube.com/watch?v=OkgvqjJzH_Y
   :END:
 - Why not Exceptions:
   - bloat binary size, can be slower
   - compiler cannot elide or optimize
 - Why
   - thread safety - impossible to ignore
   - work with RVO/NRVO
 - not best solution for everything
 - =noexcept= specifier:
   - function without noexcept then function allowed to throw
   - has specifier then can't throw
   - can have constant conditional to decide if can throw
   - can have them on lambda
 - noexcept operator: return true if expression can't throw.
 - noexcept: if noexcept function throws then std::terminate can be thrown
   - stack may/may not be unwound before terminate
 - compiler just ignores exception handlers around noexcept function calls
 - In case of generic function which calls an unknown other function then if that function were noexcept then compiler optimize away try/catch statements
   - Only uses what it needs
 - debugging unhandle exceptions can be hard
 - if you think function should be noexcept but can't then probably have a design flaw
 - forces you to think about lifetime of code
 - rather than using =-fnoexceptions= use noexcept which makes promise to users
   - compiler can make the same optimizations
 - provides more semantic information to the compiler

** Using Freestanding C++ to add C++17 to your Shellcode, UEFI, Embedded Systems
   :SOURCE:
   :Author:   Rian Quinn
   :Source:   https://www.youtube.com/watch?v=bKPN-CGhEC0
   :END:
 - Freestanding: compiler flag =-freestanding=
   - no standard libraries or C runtime support
 - Cross-compile all of llvm, lbcxxabi, lbcxx and newlib (C runtime) for the freestanding environment
   - this is to avoid rewriting stuff from the standard library
   - requires bunch of compiler flags [6:44] and linker flags [8:45]
   - CMake flags to disable a bunch of features that don't make sense [9:55]
 - The C runtime:
   - initializes global variables
   - executes main with args
 - There are a bunch of extra sections in a binary that are needed by C++ features
 - Normally freestanding environment just has =_start= function (no =main=)
 Standalone C++ Project: allows including C++ in any environment
   - supports exceptions with custom unwinder
   - header-only ELF loader
   - C loader used to load the C++ application which has std library and environment
     - C loader compiler for freestanding
   - Supports CMake
     - need a toolchain file with all the tools
   - The Loader:
     - doesn't have to be for a freestanding environment (some environments provide more than others)
     - is the entry point
     - runs =fexec= (the header only ELF loader) to load the C++ stuff
       - have to provide a print function
     - xxe: takes C++ elf binary and creates a header from it that then is included in loader
       - could also use linker
     - load ELF file into memory then execute that (at run time)
   - standalone-cxx provides several callback functions that are filled in to provide functionality
     - which functionality wanted depends on the environment
   - static variables are registered with exit function to clean up on quit
   - Only supports amd64
   - only supports static pi (PIE)
   - plans to add Windows support
** Lock Free Programming
   :SOURCE:
   :Author:   Herb Sutter
   :Source:   https://www.youtube.com/watch?v=c1gO9aB9nbs&t=2338s
   :END:
 - can be used to slipstream work, get more done at once
 - measure before and after implementing lock free
 - think in terms of transactions - taking system from one valid state to another
 - =std::atomic<T>=
 - Atomic: reads/writes indivisible
   - remember to initialize
 - 3 Types of Lock-free
   - Wait-free: no one ever waits ideal when possible provide throughput & no one will ever starve
   - Lock-free: someone making progress (individual threads may wait ( potentially forever (starve)))
   - Obstruction free
 - Double Checking Locking
   - isn't broken when using an atomic variable [20:00]
 - atomic writes can have significant overhead reads normally have little to no overhead
   - at least on x86 (more overhead on arm)
** Compute More in Less Time Using C++ SIMD Wrapper Libraries
   :SOURCE:
   :Source:   https://www.youtube.com/watch?v=8khWb-Bhhvs
   :Author:   Jefferson Amstutz
   :END:
   - SIMD wrapper libraries are not the only way to use SIMD but does do it within the type system
   - SIMD: Single Instruction Multiple Data
   - SIMT: Single Instruction Multiple Threads
   - Kernel: Code/function which is applied to multiple pieces of data
   - Good for running the same code on lots of data
   - Number of transistors in CPUs are increasing but are spent on multiprocessing
     - provides wider SIMD
     - if you're not using SIMD you're not fully using the CPU
   - SIMT expresses parallelism generally but not targeting specific hardware
     - SIMD very hardware focused
   - wrapper libraries provide abstraction over SIMD registers
   - Vc: SIMD wrapper lib (looking into standardization)
   - SIMD expressed in terms of registers with specific width (eg. 6 floats)
     - =pack=: SIMD register worth of values
       - specify width and type
       - can set width to whatever best suits ISA (instruction set)
       - pack of bool (vbool) is an exception and size depends on the logic operation you are doing
         - comparing =vint= will mean each bool in the vbool will take 32 bits
       - Data input and output of a pack with =load=, =store=, =scatter= and =gather=
         - =scatter= and =gather= take offsets to get/put values into elements of a data structure. =gather= could take {1,3,4,8} which would take those elements from an array (for example) and stick them into a pack
       - =reduce=: take all elements in a pack and process down to a single element
         - Always use the algorithm if it is provided because sometimes an instruction exists for doing this.
   - =#pragma omp for simd=: says to compiler it can vectorize even if it is worried about getting something wrong
   - Data layouts
     - Array of Structures: AoS
     - Structure of Arrays: SoA: horizontal vectorization. Prefer using this. More scalable. Readable: allows varying native SIMD register size
     - Array of Structures of arrays - AoSoA
   - Beware of overloaded =&&= and =||= operators because they won't be short circuiting (because that's how they work in C++ when they are overloaded (not a SIMD specific thing))
** A Unifying Abstraction for Async in C++
   :SOURCE:
   :Author:   Eric Niebler, David Hollman
   :Source:   https://www.youtube.com/watch?v=tF-Nz4aRWAM
   :END:
 Concurrency is not the same as parallelism.
 Concurrency: where multiple tasks run with inter-task dependencies.
 The tasks will definitely happen at the same time.

 Parallelism: there are no dependencies between tasks so they can be run in any order.
 Tasks won't necessarily happen at the same time.
 Parallelism puts less restrictions on the scheduler.

 =std::future= does type erasure, allocation and synchronization (because it has state that gets
 accessed from multiple threads), which makes it slow.

 A continuation is work to do after the =future= has finished.
 In Boost futures it is implemented as a =.then= member function.

 The talk describes a system of lazy futures, which use higher order functions.
 The system means the futures can be composed and have no allocations, synchronization, 
 or type erasure.
 They also only block when the user wants them to.

 Continuation becomes a generic algorithms that takes a lazy future and a function object
 for the continuation and returns a lambda that will do the actual work.

 Blocking can also be a generic algorithm that takes a task.

 Laziness is fundamental, things can be made eager without extra cost but eager can't be made lazy.

 There's a reference implementation of ideas in Folly.

 [Apparently co-routines are pretty cool.]
** Behind the Scenes of a C++ Build System
   :SOURCE:
   :Author:   Jussi Pakkanen
   :Source:   https://www.youtube.com/watch?v=34KzT2yvQuM
   :END:
   - all platforms have weird quirks and challenges
   - C++ & C are at the bottom of the software stack and things get weird down there
   - 2 types of build systems:
     - App build systems: makes executables (this is the build system most programming languages have)
     - Core build systems: For low-level system software (only a few systems here: makefiles, CMake, Meson (CMake and Meson are only a small part of it though))
   - C++ build systems have to solve problems other languages' build systems don't need to because of it being a systems language
   - Most projects when bootstrapping a new platform will either
     - cross compile a minimal set of tools and then compile everything else natively (the most common one)
       - Then can't use a build system using Java, Haskell, C++17, etc because the maintainers won't use it (it would be a pain to get it ported)
         - Meson uses python which has led to people not using it
     - Cross compile everything
   - Optimize build speeds
     - use shared libraries
       - provides faster linking [during build at least]
       - some linking steps disappear since if the shared libraries exported symbols don't change then nothing needs to be relinked
   - Non Turing completeness means lots of work at the start
     - it requires learning the system features and working to get new features into the system
     - but when everything is added it should all work together really well
   - Gnome Builder: container native IDE - all the dependencies are in flatpacks
** CppCon 2019: Latest and Greatest in Visual Studio for C++ developers
   :SOURCE:
   :Source:   https://www.youtube.com/watch?v=AUE76-OrI-M
   :END:
   - When loading CMake projects you can pass parameters to CMake with configuration
   - Has a CMake targets view
   - Filter in search with a character prefix
     - f: file
     - t: targets + several more
   - Can create bookmarks in code and navigate with F2
   - If CTest is configured then VS can pick up the tests and run them.
   - Static analysis runs in the background by default and shows squiggles [might not see this when using VS2015 projects]
   - Ctrl + . provides suggestions
   - 'Manage Configurations > WSL-Debug'
     - allows building and running in WSL
     - can then run in the debugger (uses GDB)
   - VS knows how to build with clang
     - is in the 'Manage Configurations' list
     - VS installer includes Clang
   - If using clang then VS uses clang-tidy and shows squiggles
   - Can create Github PRs in VS
     - it shows the CI checks as well
   - Azure Pipelines is free with GitHub for private & public repos
   - Live share environment
   - Microsoft STL is open source
   - Incredibuild in VS installer: up to 16 cores for free
   - Support more =openmp= SIMD pragmas
** How to Write a Heap Profiler
   :SOURCE:
   :Author:   Milian Wolff
   :Source:   https://www.youtube.com/watch?v=YB0QoWI-g8E&t=2s
   :END:
   - Heap profiling method used is tracing
   - Tracing requirements
     - performance - must deal with millions of events per second
     - Zero overhead when not used
   - Existing trace framework
     - perf with selt/aprobe
     - lltng-ust
     - LLVM-XRay
   - wanting to inject code into running app & intercept calls to heap (de)allocation
   - Dynamic linker can inject custom code
     - uses =LD_PRELOAD= to link library before app which makes it like the app linked against the library
     - Then can override the functions that you want to intercept
   - =dlsym= to get a pointer to function given name
   - =printf= allocates a large buffer once
   - Stack unwinding
     - needed to get a backtrace
     - on gcc & clang =-fno-omit-frame-pointer= to use frame pointer
       - need malloc to have a frame pointer
       - never mind it's really hard without compiling the entire system
     - libunwind: for doing stack unwinding
   - Symbol Resolution
     - symbols at level of linker is huge
     - can get ELF mappings with dl_iterate_phdr
       - pass it a C pointer
   - Inline Frames
     - to get the symbols that have been inlined
     - libdwfl, CU DIE
     - CU DIE lookup with =dwfl_module_addrdie=
   - Runtime Attaching
     - Code injection: open debugger and call =dlopen=
** Algorithm Intuition (part 1 of 2)
   :SOURCE:
   :Author:   Conor Hoekstra
   :Source:   https://www.youtube.com/watch?v=pUEnO6SvAMo
   :END:
- =minmax_element= gives pair with min and max of the container.
- =std::cbegin= & =std::cend= are const versions of =std::begin/end= (return 
  const iterators).
- If you find yourself writing simple lambdas check the operators in 
  the functional header.
- =iota= can be used to create a sequence. =iota(begin(v), end(v), 1);= 
  produces 1,2,3...,size of v
- Lots of the other algorithms can be implemented using =reduce= (called fold 
  in other languages)
- =inner_product= takes two ranges and two lambdas.
  - The second lambda is called first then the first lambda is called to reduce the
    results to a single value.
- =transform_reduce=: is like =inner_product= but the second lambda can be unary (so 
  transform can act on one value at a time rather than doing a zip).
- [Conor thinks using STL algorithms would mean needing to debug less but the debugger 
  would still jump in and out of the lambda]
** Algorithm Intuition (part 2 of 2)
   :SOURCE:
   :Author:   Conor Hoekstra
   :Source:   https://www.youtube.com/watch?v=sEvYmb3eKsw
   :END:
- The argument against using =inner_product= is that it has a bad name. It doesn't
  say what it does.
- =partial_sum= sums a collection but returns a list of results for each sum.
  =[1,1,1,1,1] -> [1,2,3,4,5]=
  Though it takes a lambda so doesn't just need to sum.
  - It's useful if you regularly need to sum from the beginning to various points in
    an array.
  - =inclusive_scan= does the same thing.
    - =exclusive_scan= is the same but it takes an initial value (so one extra value 
      would be in the result).
- =adjacent_difference= can be seen as a specialized =transform=.

#+ATTR_HTML: :rules all :frame border
| Algorithm                        | Indexes Viewed | Accumulator | Reduce / Transform | Default Op     | Filter aka _if |
|----------------------------------+----------------+-------------+--------------------+----------------+----------------|
| accumulate / reduce              |              1 | Yes         | Reduce             | plus{}         |                |
| inner_product / transform_reduce |              1 | Yes         | Reduce             | plus{}, mult{} |                |
| partial_sum / inclusive_scan     |              1 | Yes         | Transform          | plus{}         |                |
| exclusive_scan                   |              1 | Yes         | Transform          | plus{}         |                |
| adjacent_difference              |              2 | No          | Transform          | minus{}        |                |
| transform_inclusive_scan         |              2 | Yes         | Transform          |                |                |
| adjacent_reduce                  |              2 | Yes         | Reduce             |                |                |
| adjacent_find                    |              2 | No          | Reduce             | equal_to{}     |                |
| transform                        |              1 | No          | Transform          |                |                |
| find*                            |              1 | No          | Reduce             |                |                |
| iota                             |            N/A | N/A         | Transform          |                |                |
Even if the algorithm looks at two containers but uses the same position it counts as an index of 1.

** Hello World From Scratch
   :SOURCE:
   :Author:   Peter Bindels & Simon Brand
   :Source:   https://www.youtube.com/watch?v=4V9QWHjRPMc
   :END:
   - Hello world on C is seen as source file -> magic -> executable
   - Compilation made up of several steps
     - preprocessor
       - has macros which don't understand code
       - just handles tokens and text
       - can include files which goes all the way down until no #includes
     - Compiler
       - still at level of source (text)
       - Made up of Frontend, Middle end & Backend
     - Assembler
       - takes assembly output of compiler and encodes it to binary
       - 4 kinds of ELF files: object files, executable, shared library and core dump
       - all in same format so read the same
     - Linker
       - Take all passed-in objects
       - create lookup table of symbols referenced
       - Rewrite references to point to actual symbols
       - Look through for missing symbols
*** Compiler Frontend
    - takes preprocessed source and outputs IR
    - Lexer
      - interpret text
      - turn text into linear series of tokens that describe the text
      - After this the compiler no longer uses text
      - Lexer can be thought of as a state system
        - it reads 'A' then goes into 'A' state then reads 'B' so goes into 'B' state
        - simple language lexer can just be a switch statement
        - can also use external tool like flex to generate lexer
    - Then use parser to interpret tokens
      - parser makes use of grammar
      - generates an abstract syntax tree that allows compiler to understand the structure of the language
      - recursive descent parser?
      - hand written parser can allow for including error checking
      - automatically generated parser will check grammar
      - Recommended to use tool to check grammar then write the parser by hand
        - ANTLR is a good tool for this
    - Semantic analysis (check types are initialized correctly)
*** Compiler Middle-end
    - Intermediate Representation (IR)
      - makes it easier to support multiple languages since all languages use same tools
        - only the frontend needs to change
        - in IR want statements to be very simple so splits up statements in AST
      - Optimizations are made based on analyses
        - Example is liveness of variable
          - analyse when a variable is live. If a variable is not used after the beginning of the function then it can be gotten rid of
*** Compiler Backend
    - takes IR and transforms to assembly
    - Made up of Instruction Selection, Instruction Scheduling, Register Allocation, Target Specific Optimization & Assembly Output
      - can do one stage multiple times
    - Instruction Selection
      - picking ASM instructions to match IR instructions
        - can be macro expansion when each IR instruction is mapped to ASM instruction
          - this isn't so efficient so use peephole optimization afterwards
        - or Selection DAG (this is what LLVM uses)
          - look at IR as a Directive Acyclic Graph and look at patterns that we know are single instructions
      - Instruction Scheduling
        - when something is used and when used again
        - to make the most of instruction level parallelism
    - Register Allocation
      - fundamentally graph colouring problem
      - analyse instructions uses Leibniz analyses to form interference graph where registers that need to be alive simultaneously are connected
      - graph colouring used to say how many registers are needed
      - Register spilling: when need more registers than machine has and contents get saved temporarily on the heap
    - Target Specific Optimizations
      - take into account target specific features
*** Hello World in C++
*Compiler*
     - Some stuff about =cout= being massively complex and to use =fmtlib= instead
     - example 
       #+BEGIN_SRC cpp
 struct weird_int {
 int i;
 virtual void get_value(){};
 };
       #+END_SRC
       - gets vtable pointer to vtable which has point to =get_value= implementation
       - everything has a unique symbol so that the linker didn't need to be modified for the C++ concepts
*Linker*
     - Global initializers needs to be done before main starts
     - create global initialization function that call the constructor then destructors and objects passed to at =exit= (destroy when done)
     - need something to call this
       - =_start=: runs global initializer, main, then at exit
*From questions*
     - IR features can be added to handle specific feature of higher level languages.
     - Means there is no way for language without that feature to create that IR. So some optimizations may not be triggered for all languages.
** De-fragmenting C++: Making Exceptions and RTTI More Affordable and Usable
   :SOURCE:
   :Author:   Herb Sutter
   :Source:   https://www.youtube.com/watch?v=ARYP83yNAWk&t=335s
   :END:
 - makes proposal that more effort should be spent simplifying rather than adding features
 - Exception handling requires type erasure and RTTI requires binaries to store metadata
   - whether needed or not
 - Many projects ban exceptions completely
   - if not using exceptions then not using std C++
   - there is no way for a constructor to signal an error without exceptions
 - Why not used:
   - EH is not zero-overhead
   - increases binary sizes
   - can not statically compute space and time overhead because allocates on the heap
   - less efficient than returning by hand
** A Semi Compile/Run-time Map with (Nearly) Zero Overhead Lookup
   :SOURCE:
   :Author:   Fabian Renn-Giles
   :Source:   [[https://www.youtube.com/watch?v=qNAbGpV1ZkU]]
   :END:
 - wanted a map for wrapping java classes where 90% time lookup was with a string literal
   - though needed to work at run-time
 - =reinterpret_cast= can cause alignment or aliasing
   - =reinterpret_cast= to value is UB
 - =std::launder= as an alternative to reinterpret_cast in specific situations
** Applied WebAssembly: Compiling and Running C++ in Your Web Browser
   :SOURCE:
   :Author:   Ben Smith
   :Source:   [[https://www.youtube.com/watch?v=5N4b-rU-OAA]]
   :END:
 - WebAssembly is a typed stack machine
   - type of stack slot always known
 - validated before execution
   - like compiling but on client end
 - has machine verified formal specification
   - allows everyone to be sure implementations behave the same
 - is a Harvard architecture: programs state is separate from its code
   - impossible to modify its call stack
 - has structured control flow
   - no goto statement
   - has =block=, =loop= and =if= which allow branching to end, front and out of block
 - WebAssembly can't do anything unless allowed to
   - WebAssembly modules are imported to say what can be run
   - can mean web module and non-web module can require different imports
 - WASI: a stripped down POSIX
   - comes with libc to convert C functions to WASI equivalent. Still in dev
 - WASM time: tool to allow run WASM in native environment
 - emscripten: more mature WASI and has pretty full featureset (audio, etc.)
 - WASM doesn't officially have threads yet
   - doesn't have bunch of functions though lld and clang don't need to use them
 - WASM =nullptr= is actual location 0 in memory
   - means should leave space there in case people staring writing
 - =clang -###= shows which programs are being run under the hood
   - clang actually just runs other programs for work
 - WASI not provided by browser so need to provide implementation
 - exceptions not supported but proposal in works
   - emscripten has way of supporting them
** C++20: C++ at 40
   :SOURCE:
   :Author:   Bjarne Stroustrup
   :END:
 - using C++: focus on essentials. Use **** features only when necessary
 - Language  design not just product dev
 - Rules of thumb
   - Static type system
     - compile time error detection
     - more info allows compiler and optimizer do better job
   - value and reference semantics
   - equal support for user-defined and build-in types
   - direct use of machine resources (is an abstraction of a machine) doesn't normally run in virtual machine
     - span: ma
     - the onion principle: c++ program has layers of abstraction. Can always pull off layers (the more layers the more you cry)
   - Generic programming
     - write code work for types that meet abstract requirements
     - requirements defined as concepts
   - OOP:
     - need pointers to do inheritance cause dealing with things which don't necessarily know the type
   - Concurrency:
     - =scoped_lock= can grab multiple locks
     - mutex are OS resource so expensive. Solution to use double locked with atomic. Use heap resource to protect expensive resource
 - Coroutines:
   - invocation frames instead of stack frames
   - better generators and pipelines
   - can yield and every time called continue where it was
 - cppreference.com/w/cpp/links/libs
 - Best way to optimize is use good libs and std
   - needs enough abstraction for tools to understand what you're doing
** C++ 20: The Small Things
   :SOURCE:
   :Author: Timur Doumler
   :END:
 - Aggregates: can deduce constructors
 - Designated initialisers
   - came from C99
   - has to be alone in order
   - for aggregate initialisation
 - =Constinit=
   - forces to be initialized at compile time but isn't actually const (unlike constexpr)
 - range-based for with initializer
 - Lambdas now default constructible only if it doesn't capture
   - which allows using lambdas as member type
 - Concepts like generic functions =auto f(auto a){}=
 - Can use <template T> syntax with lambdas
 - CTAD: class template argument deduction (type deduction for templated class)
   - don't need to manually specify template type
 - =consteval=: declare function can only be used at compile time
 - =is_const_evaluated()=: checking if during compile time
 - has macro to check whether a include will work
 - can do =using enum enum_name=
 - UTF-8 char type =char8_t=
** Applied Best Practices
   :PROPERTIES:
   :Author:   Jason Turner
   :Source:   https://www.youtube.com/watch?v=DHOlsEd0eDE
   :END:
 - cppbestpractices.com
 - Strong typing
   - =trivial_type=: trivially copyable, constructible and movable. checked with =is_trivial_v= [creates a strong type with =nodiscard const noexcept= accessor]
 - Trailing return types can make it easier to see function name in blocks
 - Downside of constexpr: effectively everything must be in a header since everything must be known at compile time
 - cannot invoke undefined behaviour in a constexpr context
   - can use it to find UB
 - lambdas are const, constexpr by default
 - Must use constexpr to test constexpr code to make sure runs at compile time
   - =-Wconversion=: warns of implicit conversions
 - cppbestpractices.com has list of recommended warnings
 - use =cmake-format= to format CMake
** How to Write Shared Libraries
   :SOURCE:
   :Author:   Ulrich Drepper
   :Source:   https://akkadia.org/drepper/dsohowto.pdf
   :END:
 - Always use =-fpic/fPIC= for compiling all code that will end up in a dynamic shared object (DSO)
   - prefer =-fpic= unless specific reason
   - =-fpic= tells the compiler that the size of Global Offset Table (GOT) does not exceed an architecture-specific value
   - =-fPIC= generates code to deal with offsets of any size (More code)
   - Linker will fail and print error if it becomes necessary to use =-fPIC=
*** Export Control
 - Only export symbols that are part of ABI
   - stops users using things they are not supposed to
   - uses less memory (since fewer symbols are loaded)
 - use static for variables not needed outside file or use anonymous namespace
 - Define visibility of objects explicitly
   - Can mark objects with =STV_DEFAULT= or =STV_HIDDEN=
   - Combine =DEFAULT= with cli flag
   - =-fvisibility=hidden= to only export API
     - this method prevents symbols being accidentally exported
 - Can set visibility of individual symbols with attribute:
   #+BEGIN_SRC c
   __attribute__((visibility ("default")));
   #+END_SRC
   or a block with pragma:
   #+BEGIN_SRC c
   #pragma GCC visibility push (default)
   <code>
   #pragma GCC visibility pop
   #+END_SRC
   Warning: use of protected visibility mode is discouraged and slow
 - more complicated in C++: key is to mimic actual symbol access as closely as possible
   - normally safe to not export inline functions
     - =gcc option -fvisibility-inlines-hidden= does what is required
   - can mark entire class with macro above or with 
     #+BEGIN_SRC c
     class __attribute((visibility("hidden")))
     foo { ... };
     #+END_SRC
   - gets complicated to do it right with C++
 - Export Maps: control visibility with the linker
   - should be used in addition to the other methods
   - used to specify which symbols are global (exported) and local
     - should set local to '*' to catch all unspecified symbols (avoiding unspecified behaviour)
   - for C++ can either specify the mangled names or (with linker support) demangled names with =extern C++ {...}=
 - Shorten Symbol Names:
   - length of symbols has cost on symbol lookup since entire symbol of successful lookup has to be checked
   - Can be sped up by using shorter names
     - Potentially alias/wrap C++ classes
   - consider a micro-optimization
 - Generated DSO code often larger & slower than application code since it has to be relocatable rather than assume fixed load address.
*** API + ABI Stability
 - to make changes to ABI but maintain support for old programs must version .so
   - simplest is different filenames
   - Linux supports versioning of symbols in DSO so dynamic linker can check if required version exists at run-time
 - when export mapping can export based on version string
 - Often a problem where unneeded dependencies DSOs are specified on linker command line and resulting library becomes dependent on them
   - to list unused direct dependencies: =ldd -u -r file.so=
   - linker flag =--as-needed= only adds dependency if actually needed
** Undo-Debugging Linux C++ 
   :SOURCE:
   :Author:   Greg Law
   :Source:   https://www.youtube.com/watch?v=V1t6faOKjuQ
   :END:
 - Sir Maurice Wilkes - very early programmer
 - Two kinds of tools
   - Checkers: static & dynamic: did code do thing
   - Debuggers: what exactly did my code do
 - GDB: easy to use, not easy to learn
   - use gcc =-ggdb3= (not just -g)
   - 'start' - temporary breakpoint or main
   - C-x a: gives a TUI (ncurses interface)
     - C-l : refreshes the screen
     - GDB has a full python interpreter
   - keep .gdbinit simple
     - =set history save=: saves command history across sessions
   - =rwatch foo=: stop when foo is read
   - =watch foo thread 3=: stop when thread 3 changes foo
   - =thread apply all <option>=: apply option to all threads
   - =dprintf=: dynamic printf puts printfs in code without recompiling
   - =call foo()=: will call foo in inferior
   - catchpoints: like breakpoints but catch events like exceptions, syscalls
   - =tbreak=: temporary breakpoint
 - Valgrind:
   - memcheck is the default
   - run with =valgrind ./a.out=
   - =valgrind --vgdb ./a.out= for debugging. This runs gdb server
     - because valgrind adds in code so can't be run straight in gdb
 - Sanitizers: come bundled in compiler
   - do similar thing to valgrind but are much quicker. There is performance overhead though
   - =gcc -fsanitizer=<sanitizer>= (eg. =-fsanitizer=address=)
 - =rr=: reversible debugging
   - can then replay last run, requires recent Intel cpu
 - =strace=: for tracking system calls for process
 - =ltrace=: trace all dynamic library calls of a process
 - =perf= trace: like strace but faster though needs root privileges
** Better Tools in Your Clang Toolbox
   :SOURCE:
   :Author:   Victor Ciura
   :Source:   https://www.youtube.com/watch?v=4X_fZkl7kkU
   :END:
 - clang powertools
 - clang-build.ps1 powershell script for compiling/clang-tidying visual studio projects
   - works well with running with Jenkins
   - install powershell plugin
   - add powershell action
   - pick the trigger
 - Clang Power Tools VS extension extremely configurable
 - adopting the tool resulted in cleaner more modern code
*** Massaging the Code
 - stay ISO C++ standard conformant
   - clang power tools helps
 - clang-tidy found lots of subtle bugs
 - if allowing non-standard construct you will encounter issues (if compiler gets more strict, or portability)
 - can be iterative in conformance:
   - =-fno-delayed-template-parsing=
   - =-Werror=microsoft=
   - =-Werror=typename-missing=
   - =-Wno-xyz-warn= (=-Wno-microsoft-sealed=)
 - clang-tidy: several modernize checks
 - other useful flags: =-Wreorder=, =-Wunused-private-field= 
 - Tools: =add_new_check.py=: automates adding new check (creates test, update Cmake, creat test)
 - [51:40] several string related checks
 - =-Wlifetime= on recent clang gives Herb Sutter's lifetime profile
 - LLVM Compiler Toolchain: VS extension for building using LLVM in VS

** Overloading - the Bane of All Higher-Order Functions
   :SOURCE:
   :Author:   Simon Brand
   :Source:   https://www.youtube.com/watch?v=L_QKlAx31Pw
   :END:
 - passing templated functions to function is verbose (have to specify type)
   - passing function object better but calling that verbose (have to instantiate object)
 - can wrap it in lambda
   #+BEGIN_SRC cpp
   [](const auto& t){return foo(t)};
   #+END_SRC
   - [7:55] can get very messy to add
 - can use a macro
 - [9:14] global function object
   - define in header then create const object in implementation. Don't need to construct cause always has 1 already
   - causes problems with header only and multiple instantiations
 - passing overloaded functions are icky though there are workarounds
** C++ Function Templates: How Do They Really Work
   :SOURCE:
   :Author: Walter E. Brown
   :Source: https://www.youtube.com/watch?v=NIDEjY5ywqU
   :END:
 - Misinformation:
   - Functions templates are special functions
     - No, function templates aren't functions
   - Function template behave like a function
     - template has no function like behaviour
 - there is a difference between templated function and function template
 - templates usually defined in headers
 - often characterized as generic algorithms
 - From template compiler can: synthesize function
   - instantiate function definition
 - explicit specializations: typically compiler that instantiates
   - programmer may specify: for treating specific version in a different way
   - distinguished by template<> (empty brackets)
 - can force a particular specialization is used by providing own type as a substitution for the template parameter
 - specialization are never candidates for overload resolution
 - compiler seeks most specialized of possible function matches
*** Recommended
 - C++ Templates: The Complete Guide 2^{nd} edition: Vandevoorde, Josuttis & Gregor
   - "consider the bible for anything to do with templates"
** Modern C++ in Embedded Systems
   :SOURCE:
   :Author:   Michael Caisse
   :Source:   https://www.youtube.com/watch?v=c9Xt6Me3mJ4
   :END:
 - MPU - like MCU but with resource offboard (eg. RAM is off board)
 - TCM: tightly couple memory. Connected directly to core.
 - C++ provides better abstractions
   - embedded world dislikes abstractions
 - often have to use vendors tools because the chips require proprietary code for doing things like pin routing
 - better starting with vendor tools to get basis for starting
 - most embedded world hates C++
   - vendors disables ways to use C++ in their tools and make it as hard as possible
 - CMake for cross-compiling use a toolchain file [28:52]
   - when checking everything works create a static library cause doesn't care about things like startup code
 - runtime polymorphism has a lot of overhead
   - CRTP: gives static polymorphism and is more efficient
   - Compilers actually can use devirtualisation to see through most runtime polymorphism to get a lot of the performance benefits
     - but not always
 - =-Os=: =O2= but without anything that affects size
   - =-Os -Og= apparently good combination
 - necessary to have linker script to match device memory
   - can start with vendors tools' linker script but likely won't work properly with C++
   - standard compilers come with linker script (won't fit embedded chips memory though)

** Modern C++ in Embedded Systems - The Saga Continues
   :SOURCE:
   :Author:   Michael Caisse
   :Source:   https://www.youtube.com/watch?v=LfRLQ7IChtg
   :END:
 - manufacturer provided IDEs:
   - often geared towards time to hello world
   - focused on single developer workflow
   - hides a lot of magic (makes it hard to set up own solutions)
 - =dockcross=: somehow makes docker easier to manage
 - runtime optimizations: have to be enabled in the linker and compiler
 - static polymorphism [36:30] CRTP
   - uses templates
   - results in smaller code but still results polymorphism
 - Devirtualisation will do similar thing as CRTP but doesn't happen immediately to see how your code works you have a problem
 - =Ladon=: something like protobuf
 - can't use rtti or exceptions
 - need to take ownership of startup code & linker script
** Surprises in Object Lifetime
   :SOURCE:
   :Author:   Jason Turner
   :Source:   https://www.youtube.com/watch?v=uQyT-5iWUow
   :END:
 - well defined object lifetime key feature
 - object: anything not a function or reference
 - string literals are statically constructed so are valid for the life of the program
 - =vector::emplace_back=: calls types constructor directly? Creates in place I think
 - =std::array= implemented as struct so contents are directly initialized (doesn't use initializer_list)
 - undefined to use '_' capital letter at start of name
 - ranged for loops create their own hidden variables
 - =-Wshadow=: catches some issues
 - Sanitizer
 - "don't name temporaries you don't have to. It makes the code more modular"
** Modern C++ Testing with Catch2
   :SOURCE:
   :Author:   Phil Nash
   :Source:   https://www.youtube.com/watch?v=Ob5_XZrFQH0
   :END:
 - supports =-fno-exceptions=
 - Matchers: CHECK_THAT & REQUIRE_THAT
   - matcher includes contains "string", substring vector. Can be added to.
   - can be composed
 - Generators: used to provide multiple values for variables. Test case runs for every value of the generator
   - also can have random numbers
 - Property based testing: working with ranges of data. (not there yet)
   - will try and find simplest failure case
 - BDD: behaviour drive development
** Understanding Optimizers
   :SOURCE:
   :Author:   Nir Friedman
   :Source:   https://www.youtube.com/watch?v=8nyq8SNUTSc
   :END:
 - Basic block: straight line code sequence with no branches and no branch out except exit
   - compiler can rearrange stuff
 - Inlining: make other optimizations possible (adding function into same basic block)
   - also causes code bloat (unless function called rarely)
 - const propagation: when knowing value at compile time influences the assembly
   - =find_if= with a function pointer often won't be inlined
 - const often doesn't make a difference to the compiler
 - interesting optimization with two memcpy and a placement new instead of doing reinterpret_cast [45:00] - isn't const correct

** How C++ Debuggers Work
   :SOURCE:
   :Author:   Simon Brand
   :Source:   https://www.youtube.com/watch?v=0DDrseUomfU
   :END:
 - ELF: ange albertini website has graphic
   - header: what machine, etc.
   - codes separated into sections
 - DWARF: Linux debug format
   - DIES contains all information (functions, files...)
   - used by debugger to get proper info
   - line table info: which lines of source for which machine code
 - ptrace: single function. send request and data
   - depending on request will do different things with data
 - Breakpoints: two main kinds
   - Hardware: set special registers which write value to. When hit address it breaks. Limited number. Can break on read/write/execute.
   - Software: modify running code in memory to have breaking instructions. Can break on execute.
     - generally implemented similarly across platforms
     - debugger takes first byte of instruction and replaces with OXCC instruction (int3) which triggers software interrupts
     - OS registers interrupt handlers
   - for setting breakpoints on line: takes the DWARF line info and sets break on instruction
   - step out: set breakpoint at return address
   - step in: at return address or next instruction in caller
     - working out next instruction requires understanding of target (could jump anywhere)
     - must inspect code to work out all possible targets. Debuggers ship with instruction emulator
 - Registers & Memory
   - read registers with ptrace call
   - read with PEEKDATA call, write with POKEDATA
     - only works a word at a time
     - at [030:47] other better methods
 - shared libraries
   - somewhere in program is data structure with data on where everything is loaded
   - sets breakpoints to trace shared library loading
 - Remote Debugging:
   - lots of debuggers use remote debugging for everything (easier to implement)(lldb does this)
   - Debug stub doesn't have access to all debug info

** Latest and Greatest in the Visual Studio Family
   :PROPERTIES:
   :Author:   Steve Carroll & Marian Luparu
   :Source:   https://www.youtube.com/watch?v=6NAAuxWNhk4
   :END:
 - clang-format directly integrated
 - setup environment with vcpkg [8:14]
   - connect visual studio to VM [10:49]
     - can use rsync to keep headers synced for intellisense to use
     - can find errors for other config (Platform)
     - connect to running process in VM [15:45]
 - supports googletest & boost test (finds and runs them with build)
 - VS 2017 supports C++ 11, 14, 17
 - =/permissive-=: guarantee portability, removes VS extensions
   - not on by default
 - All compilers are shipped with VS2017 (old VS compilers)
   - want to guarantee everyone can upgrade

** Avoiding Disaster with Strongly Typed C++
   :PROPERTIES:
   :Author:   Arno Lepisk
   :Source:   https://www.youtube.com/watch?v=1fwbG5TyI18
   :END:
 - could wrap the type in structs so they are distinct
 - can use a template where template<typename tag> and tag is only used for identifier and not used in template (but different tags are different types)
   - can use with =using= to get different types
 - implemented in type_safe_library
   - base type, ID and concepts for features enablement
   - get function to get underlying type out
   - easy to add own skills (use structs)
   - for operations that create another type [19:10] (minus 2 values to get offset)
 - =std::ration= standardized way of doing rationalized arithmetic at compile time
   - can be used to define ratins for strong types by having ration in the template [26:00]

** UEFI with Modern C++
   :SOURCE:
   :Author:   Morris Hafner
   :Source:   https://www.youtube.com/watch?v=z6wKEJ-daD4
   :END:
 - BIOS - calls interrupts instead of functions
 - EFI - coff file format
   - MS calling convention
 - Toolchain: Tianolore EDK II, GNU efibb (easier to use)
   - does not work with clang
   - no C++ stdlib but many headers can be used from host since they are compile time construct
   - Compiler invocation [6:06]
     - entry point isn't main (efi-main)
   - can run it with QEMU [8:15]
 - Protocol Interface:
   - firmware services queried with GUIDS
   - everything loaded in structs
   - OO style interface but in C (function pointers)
   - Morris wrapped all in C++ function
 - graphics to framebuffer [22:00]
 - avoided the heap
 - technically incorrect code
   - C++ standard says for standalone applications only requires subset of C stdlib

** A Little Order: Delving into the STL Sorting Algorithms
   :SOURCE:
   :Author:   Fred Tingaud
   :Source:   https://www.youtube.com/watch?v=-0tO3Eni2uo
   :END:
 - stable sorting: series of sorts by different qualities are maintained
   - sort by colour then height: after height still sorted by colour
 - =nth_element=: sort only 1 element
 - =partial_sort=: everything up to point
   - does less than sort by takes longer
 - =std::sort= - O(N-log_{n}) guaranteed since 11
 - calling sort on result of nth_element is faster than partial_sort
   - for certain input?
 - use partial_sort when sorting a small number of elements in a big container
 - use nth_element & sort for everything else
 - complexity in algorithms is important but so is real world use cases
   - sometimes technically slower algorithms work better for specific cases

** C++ at High Subsonic Speed
   :PROPERTIES:
   :Author:   Arne F\oslash{}rlie
   :Source:   https://www.youtube.com/watch?v=1c4H9ftkHcU
   :END:
 - military development very slow
 - goes UML interface -> generated IDL -> Generated C++ interface -> executable code
   - make easy to write application code
   - application task can't use any OS calls
 - everything is reusable components
   - no precompiled libraries
 - compiler version & config controlled by build system
   - big jump in gcc caused issues, new compiler rejected code
   - gets new GCC version every year
 - Compiler warnings:
   - quite restrictive
   - GCC & Clang use =-isystem= to specify include file search path (suppress warning in dependencies)
 - Static analysis: QAC++
 - Run time analysis: valgrind, address sanitizer (GCC), Undefined behaviour sanitizer (GCC)

** Compiling Multi-Million Line C++ Codebase Effortlessly with the Meson Build System
   :PROPERTIES:
   :Source:   https://www.youtube.com/watch?v=SCZLnopmYBM
   :Author:   Jussi Pakkanen
   :END:
 - project created with init command (move like leiningen)
 - automatically runs unit test parallel
 - provides coverage reports
 - native precompiled headers?
 - cross compilation is simple
 - Dependencies:
   - has option where if project has submodule same as parent then return parents variable
   - dependency can be optionally system or build yourself if system not found
   - can build specific targets and it'll only pull those dependencies
   - support mono repos
 - Python thing
   - Meson implemented in Python
   - design principal: should be able to mix and match programming languages
   - [example mixing C, C++, Rust, Fortran, 21:39]
   - build definition file should explain what should happen (not how to do it)
 - Managing dependency [example two]
 - =wrap= command to download dependencies from database
   - db consists upstream tarball & community written build definitions
 - adding linting tools:
   - meson has run targets which specifies a carnnonel
   - could create target for linter and point to compilation database

** Concepts: The Future of Generic Programming
   :SOURCE:
   :Author:   Bjarne Stroustrup
   :Source:   https://www.youtube.com/watch?v=HddFGPTAmtU
   :END:
 - good generic code helps write better code
 - concepts likely to be in C++20
 - History: 80s- generic code use macros
   - 87-now: goals of extremely flexible, zero overhead
*** Templates
 - advantages: flexibility, type safety, specialization, good run-time performance
 - disadvantages: verbose syntax, duck typing, had error messages, clumsy overloading, week code organization, slow compilation
 - Concepts allow for specifying certain qualities of types
*** Concepts
 - Types and Concepts:
   - Types: Specifies what operations can be applied to an object
   - Concept: specify how you can use object
     - says nothing of layout of object
 - Benefits Of Concepts:
   - support good design:
   - better maintainability
   - overloading: like functions but simpler
 - enable_if?
   - though leads to ugly code

** Cross Language Interfaces Between C and C++
   :SOURCE:
   :Author:   Jens Gustedt
   :Source:   https://gustedt.wordpress.com/2017/08/08/cross-language-interfaces-between-c-and-c/
   :END:
 - It makes no sense to compile C as C++ and vice versa
   - Both languages agree on the ABI so data structure and functions can be shared
 - most types are the same in both except =bool=
 - Arrays can have dynamic length in C
 - Boolean in C is actually _Bool with macro bool
   - for cross interface that uses bool: use =bool= and 
     #+BEGIN_SRC cpp
     #ifdef __cplusplus
     #include<cstdbool.h>
     #endif
     #+END_SRC
 - Plain enumerations are the same in both
   - enumeration constants have different types and rules for implicit conversion
 - different ways of specifying atomics. Easiest solution is to create macro from C way to C++ way for C++.
 - In C can't specify cont at object definition
   - have to use macros
 - functions that take no params in C must be defined with void
 - C: requires programmer to provide instantiation of inline function

** The New C++17 and Why It's Good For You
   :SOURCE:
   :Author:   Timur Doumler
   :END:
 - full feature list: wg21.link/p0636
 - if with initializer:
   #+BEGIN_SRC cpp
   if(auto var = something(); test)
   dosomething();
   #+END_SRC
   - useful for adding lock just for if statement
 - structured bindings
   - allows to easily assign rvalues from struct, C arrays, std::array, std::pair, std::tuple to individual variables
     #+BEGIN_SRC cpp
     auto [x,y,z] = getPosition();
     #+END_SRC
     getPositon() returns Point struct which contains 3 doubles that are now split between x,y,z
   - iterate over map (values are pairs):
     #+BEGIN_SRC cpp
     for(auto& [key,value] : map)
     #+END_SRC
   - works with if initializer
 - class template argument deduction
   - deduces class template types from constructor arguments
     #+BEGIN_SRC cpp
     vector<int> mVector{1, 2, 3};
     /* becomes */
     vector mVector{1, 2, 3};
     #+END_SRC
   - supports user-defined deduction guides
 - if constexpr
   - checks condition at compile time and only compiles if it is true. Likewise if it was true it won't bother compiling the else branch
 - aligned heap memory: alignas now works on the heap (new is aware of it)
 - atomics: static function =is_always_lock_free= to check atomic of certain type if always lockfree.
   - cache lines: can accidentally make two atomic variables on same cache line which is problem
     - c++17 can use alignas with std::hardware_destructive_interference_size (gets L1 cache size)
 - return by value: compiler can optimize return by value
 - Return Value Optimization
 - Named Return Value Optimizations (something is now fixed)
 - =std::clamp=: constrain value between two given values. Has overload to supply own comparison operator.
 - =std::variant=: data type that can be either of two different types: =std::variant<int, std::string> u;= can be initialized as either an int or string.
   - =get_if<>= can be used to get value if it is currently of that type.
   - if one tries to put a new element in and it fails then the variant is empty
   - can be used in real time code since never allocates.
 - =std::any=: can have any type
   - =any_cast<T>(a)=to get value. Throws exception if wrong type
   - =has_value()=
   - =reset=
   - =any_cast<T>(&a): returns nullptr if wrong type
 - =std::optional: alternative for error handling. Either has value or is empty. Dereferences like a pointer (though will crash if doesn't have value)
*** Application Framework Features
 - filesystem
   - lots of freestanding functions
   - works well with different directory systems
** C++ Weekly
   #+TOC: headlines 1 :target "C++ Weekly"
*** Ep 2 - Cost of Using Statics
  - compiler has to create statics in thread safe way. Has to have code to check if variable is constructed
    - performs this check every time variable accessed.
  - can get around by maintaining a reference to the static variable after its constructed to use to reference it.
*** Ep 3 - Intro to clang-tidy
  - requires clang install
  - requires same compile commands file as cquery
    - specify with =-p=
  - provide files to check as cli argument
  - =-list-checks= shows the checks
  - enable all checks with =-check=*=
  - =-fix=: automatically fixes issues (don't completely trust)
  - can enable clang-tidy for a CMake project by 
    #+BEGIN_SRC bash
    cmake .. -DCMAKE_CXX_CLANG_TIDY:STRING='clang-tidy;-checks=*,readibility=*'
    #+END_SRC
*** Ep 6 - Intro to Variadic Templates
  - allows creating template functions that take variable number of arguments with different types
  - declared with =template<typename... NAME>=
  - function parameter looks like:
    =function_name(...variable_name)=
    - acccessed with: =variable_name...=
  - can increase compile times because it can end up instantiating lots of different functions
*** Ep 8 - Name Demangling
  - compiler takes human readable names and mangles it into compact thing
  - =nm= command shows names of types
    - eg. =nm a.out=
  - =c++filt -t= shows demangled names
  - getting the demangled name at runtime:
    - use =typeid= operator
      - =typeid(variable).name()= gives mangled name
      - In GCC: =__cxa_demangle= gives the demangled name when given mangled
  - From comments:
    - apparently crash report systems use name demangling form human readable stack traces.
*** Ep 9 - std::future Quick Start
  - =std::async= - calls a function asynchronously
    - returns a future: which promises to have a value at some point in future
      - =future::get= returns stored value
    - by default chooses whether to actually run async or just differed until =get= is called
      - can queue up calculations that you're not sure will be needed or not
    - can force to be async with =std::launch::async= as first argument
  - futures can store and forward exceptions
  - only pass and return copies and don't access or change global state means not having to worry about manual locking.
*** Ep 14 - Standard Library Gems
  - =std::next=: returns next forward iterator from the one passed
    - increments the most efficient way possible
    - also takes number of steps to move forward
  - =std::exchange=: replaces value of object with new value and returns the old value
    - so can do =last=std::exchange(i, new_value);=
    - does moves & forwards so prevents no copies if possible
*** Ep 15 - Using std::bind
  - takes callable object (something that can be called as if it were a function and list of arguments to bind to function)
  - guarantees to make a copy of arguments passed in
  - if want it to track changes to variables need to make =std::ref= wrapper around variable:
    =std::bind(&Function, std::ref(i));=
  - returns a function (object? pointer?) that can be called which will call the bound function with the bound arguments
  - heavyweight in terms of compilation
  - can also specify arguments to be specified by user when the returned function is called [4:26]
    - using =std::placeholders=
  - can also reorder parameters using placeholders
  - bind swallows any extra arguments passed to it
  - functions requires to be concrete so when using templates must provide type when passing function to bind
    - since generic templates aren't callable
  - =std::ref=: helper function for creating =std::reference_wrapper= using template argument deduction to determine template argument
  - =std::reference_wrapper=: stores references in copyable, assignable object
*** Ep 78 - Intro to CMake
  - configuration goes in CMakeLists.txt
  - cmake_minimum_required(VERSION x.x)
    - minimum cmake version
  - =add_executable(name file)=
  - can specify which executables require which features: =target_compile_features(exe_name PRIVATE feature)=
  - ccmake: provides a graphical interface to configure (can select compile etc.)
  - =add_compile_options(options)=: eg. for options -Wall Switches to be added to compile command
    - -Wall -Wextra -Wpedantic
  - =set_property=: can be used to select c++ standard version. =target_compile_features= is the recommended way though.
  - if block follows style:
    #+BEGIN_SRC cmake
    if()
      ~~~~
    else()
      ~~~~
    endif()
    #+END_SRC
  - CXX_EXTENSIONS property
*** Ep 84 - C++ Sanitizers
  - does runtime analysis of code
  - thread, address, memory, undefined behaviour sanitizers add instrumentation to code
  - flag has to be passed at runtime and link time
  - Address sanitizers: prints information on memory address incorrect access
  - on Ubuntu need to tell clang where to find symbolizer to get line numbers
  - Memory
    - warns at uninitialized memory
  - have runtime performance overhead as they add code to the executable
*** Ep 88 - Don't Forget About Puts
  - including iostream creates some global variables (cout, cin) that the compiler must initialize
  - using =cstdio= and =printf= avoids this
  - =printf= uses =puts=
  - using =puts= makes the program far simpler and removes the control character support of =printf=
  - =puts=: prints c-style string to stdin followed by newline
    - requires null terminated string so call with: 
      =puts(string.c_str())=
*** Ep 133 - What Exactly Is A Lambda
  - compiler creates a type for created lambda
  - something like a struct/class
    - with const operator()
  - because operator() is const means can't mutate captured variables
    - to get around this can add =mutable= keyword:
      eg. =[]()mutable{}=
      - this effectively removes the const
  - making lambda generic implicitly creates a template function
    eg. =[](auto i){}=
  - C++17 made the operator() constexpr
    - this is prevented by capturing variables
  - CppInsights shows how the compiler changes code
*** Ep 134 - The Best Possible Way To Create A Visitor
  - Possible to inherit from lambdas
  - the visitor shown use variadic templates to inherit from a set of lambdas
  - use base class operator with 
    =using Base::operator()=
  - seems to use two lambdas as base to provide two potential results depending on type of argument
  - goes on to show how it can be simplified and made mostly constexpr
*** Ep 145 - Semi Automatic constexpr & noexcept
  - compiler needs to know if can be constexpr for C++ 17 lambdas
  - knows if noexcept for exception optimizations
  - VS 2017 analyser:
    - provides recommendation for constexpr & noexcept
*** Ep 146 - C++ 20's std::to_addres
*** The Important Parts of C++ 98 in 13 Minutes
  - C++03 had a few tweaks
  - C++ has deterministic object lifetime
    - can predict exactly where object is created and destroyed
  - C++11 should almost never have to write own destructors
*** C++ 20's std::bind_front
  - Lots of ways of binding in functional
  - Probably to replace std::bind though doesn't have all flexibility (probably good)
  - =std::bind_front(&function, arg1, arg2 ...)=
    - seems to do the bind without all the reordering
*** Spaceships in C++20
  - When creating custom types lots of boiler plate code to write all operators
  - Spaceship operator allows all that to be generated
    #+BEGIN_SRC cpp
    operator<=>(const T rhs) const = default;
    #+END_SRC
  - provides all the comparison operators
  - need =#include<compare>=
** Additional
*** [[https://www.youtube.com/watch?v=FtZEU9zv9eM][Sean Parent - Generic Programming]]
    - Think of iterators as pointing between elements, not to them
      - each element is bounded
      - so =.end()= doesn't point to an element off by 1, it marks the end of the container
    [Informative, mostly history talk]
* Audio Programming                                                   :audio:
** Using Locks in Real-Time Audio Processing                            :cpp:
   :SOURCE:
   :Author:   Timur Doumler
   :Source:   https://timur.audio/using-locks-in-real-time-audio-processing-safely
   :END:
 When streaming data from one thread to another you can use a single producer single consumer (spsc) FIFO.
 When the audio thread shares the data with the other thread then try to make immutable copies. 
 When this isn't possible then locks may be uses (as a last resort).

 Don't use =std::mutex::try_lock()= because while =try_lock= doesn't block if the mutex is acquired then when the lock goes out of scope =std::mutex::unlock= is called.
 Normally this isn't a slow operation except when another thread is waiting for the mutex.
 Then it requires a system call to interact with the OS scheduler to wake up the thread.

 A simple spinlock is an option but the waiting thread will spin, maxing out the CPU core and preventing other threads getting work done.
 This can be improved by exponential back-off where it:
   - tries to lock a certain number of times
   - then starts using CPU pause instructions between requesting the lock
   - then asks the scheduler to put the thread in the run queue
   - then starts putting the thread to sleep
 This results in progressively longer wait times the longer we fail to get the lock.
 [Has an implementation from Bryce Adelstein Lelbach's C++20 synchronization library talk though this is optimized for hundreds of threads]
 The pause can be done with the =_mm_pause()= intrinsic on Intel.
 Put back in run queue is done with =std::this_thread::yield()=.
 The problem with =yield= is it requires the kernel to do lots of work.
 In the case with few threads then =yield= will put the thread on the queue then immediately schedule it back in.
 This will result in a high CPU load if it is happening in a loop.
 So you only want to yield when there's lots of threads and lots of work being done.
 *Don't yield in a loop.*

 Putting the thread to sleep is also a problem since it involves a yield but also the time between each audio callback is very small. 
 So a waiting thread could easily miss the window where the mutex is available.

 Tuned exponential back-off for audio looks like:
   1) Loop 3 times trying to get lock with =try_lock()=.
   2) Loop 10 times trying to the lock then calling =mm_pause()=.
   3) Loop 3000 times calling =try_lock()= then calling =mm_pause()= 10 times in a row.
   4) Yield the thread to allow the scheduler to get things back under control since the system is obviously under high load.
   5) Alternate between steps 3) & 4) until the lock is acquired.
 Step 3) provides a low energy step that is still short enough that it will still probably catch the mutex between audio callback calls.
 It calls =mm_pause()= 10 times in a row rather than in a loop because that prevents the CPU from having to do work with incrementing and checking a counter.
 Apparently most (all?) compilers won't unroll that loop.
** Real-time Audio Programming 101: Time Waits For Nothing
   :SOURCE:
   :Author:   Ross Bencina
   :Source:   http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing
   :END:
 - 8 ms is a rough target latency for interactive systems.
 - If you don't know how long something will take then don't do it.
   - audio code must always take a predictable amount of time
 - always look at the worst case performance of algorithms. Most of the time the average case is presented.
 - Never use a lock when controlling audio from a lower priority thread
   - Priority inversion: if the audio thread shares a lock with a low priority thread the low priority thread can be interrupted while holding the lock causing the audio thread to wait for the interrupting thread and the low priority thread to finish.
     - Priority inheritance locks elevate the priority of the thread holding the lock to the priority of the thread waiting. Available in Linux as PTHREAD_PRIO_INHERIT
   - Can accidentally call code with unbounded execution time
   - Extra interaction with the thread scheduler
 - Trylocks: in the worst case code may never acquire the lock.
 - Memory allocation: never do it in an audio callback. Possible solutions:
   - Pre-allocate all data
   - Only do dynamic allocation in a non-real-time thread when it isn't time critical
   - Allocate a memory pool and use your own deterministic dynamic allocator which only the audio callback uses (so no locks)
 - GC: real-time GCs exist. The GC can interrupt the audio callback.
 - Page faults: OS can page out memory that is used by the callback. Normally won't if the memory is used frequently but is possible especially if low on memory.
   - Possible to lock memory in RAM with =mlock/munlock= (UNIX) or =VirtualLock/VirtualUnlock= (Windows).
 - Don't wait for hardware or external events
   - eg. disc i/o
 - Don't use system API functions unless specifically marked as real-time
   - Never know how long they will take or if they lock/perform allocation/ disk io
 - Use algorithms with good worst case time complexity (ideally O(1))
 - Amortize computations across many samples to smooth out the CPU load rather than using "bursty" algorithms which sometimes take longer.
 - Pre-allocate & pre-compute date in non-RT thread
 - Use audio callback only data structures so you don't have to worry about concurrency
 - Use a lockfree FIFO to send data and commands between the RT and non-RT threads.
** Real-time 101 Part 1: Investigating the Real-time Problem Space
   :SOURCE:
   :Author:   Fabian Renn-Giles & Dave Rowland
   :Source:   https://www.youtube.com/watch?v=Q0vrQFyAdWI
   :END:
#+name: real-time
#+header: :results output graphics file
#+header: :imagemagick yes :headers '("\\usepackage{tikz}")
#+header: :fit yes :iminoptions -density 1000 :imoutoptions -geometry 400
#+BEGIN_SRC latex :file images/real-time.png
  \usetikzlibrary{shapes.geometric,arrows,positioning}
  \tikzstyle{startstop} = [rectangle, text width=4cm, minimum width=1cm, minimum height=1cm, text centered, draw=black]
  \tikzstyle{arrow} = [thick,->,>=stealth]
  \begin{tikzpicture}[node distance=2cm, auto,]
    \node (start) [startstop] {Sharing or passing object between threads?};
    %% The direction should be wrong but it doesn't work without it like this
    \node[right=of start] (FIFO) {FIFO};
    \draw [arrow] (start) -- node[anchor=south]{Passing}(FIFO);
    \node[startstop, below of=start] (RTThread) {Interacting with a RT thread?};
    \draw[arrow] (start) -- node[anchor=west]{Sharing}(RTThread);
    \node[right=of RTThread] (Locks) {Use locks};
    \draw[arrow] (RTThread) --node[anchor=south] {No}(Locks);
    \node[startstop, below of=RTThread] (lockFree) {Shared data is\_always\_lockfree?};
    \draw[arrow] (RTThread)--node[anchor=west]{Yes}(lockFree);
    \node[right=of lockFree] (atomic) {Use std::atomic};
    \draw[arrow] (lockFree)--node[anchor=south]{Yes}(atomic);
    \node[startstop, below of=lockFree] (acquireResource) {Failure to acquire resource OK?};
    \draw[arrow] (lockFree)--node[anchor=west]{No}(acquireResource);w
    \node[right=of acquireResource] (trylock) {Use trylock};
    \draw[arrow] (acquireResource)--node[anchor=south]{Yes}(trylock);
    \node[startstop, below of=acquireResource] (RTThread) {Does RT thread mutate object?};
    \draw[arrow] (acquireResource)--node[anchor=west]{No}(RTThread);
    \node[right=of RTThread] (CAS) {CAS loop};
    \draw[arrow] (RTThread)--node[anchor=south]{No}(CAS);
    \node[startstop, below of=RTThread] (nonRTThread) {Does nonRT thread mutate object?};
    \draw[arrow] (RTThread)--node[anchor=west]{Yes}(nonRTThread);
    \node[right=of nonRTThread] (buffer) {Double buffering};
    \draw[arrow] (nonRTThread)--node[anchor=south]{No}(buffer);
    \node[below of=nonRTThread] (combo) {CAS loop/FIFO combo};
    \draw[arrow] (nonRTThread)--node[anchor=west]{Yes}(combo);
  \end{tikzpicture}
#+END_SRC

 Real-time: correctness relies on the logical output and the time it was returned.
 Audio: Hard to firm real-time system.
 RT thread gets an uninterrupted period to run in.
 It must run within this time otherwise it can be marked as a normal thread and can be scheduled out before it's finished.
*** Context Switch
 Loading the state of a thread into the CPU when it is scheduled in. The address space can move and the cache changes.
*** Memory Access
 Memory can get moved to various levels of caches, RAM or to disc (disc is terrible).
 To keep memory in caches we can have a thread that pokes the memory we need to keep it in the cache.
 =mlock=/=munlock= (POSIX) and =VirtualLock=/=VirtualUnlock= (Windows) tells the OS never to page certain memory to disc (this can break the system if it used too much because the OS will run out of memory).
*** Priority Inversion
 The high priority thread can wait for a low priority thread if the low priority thread gets a lock first then performs an expensive operation.
 Also a problem if the low priority thread gets put to sleep after getting the lock.
 Don't rely on things that say =std::atomic=, they aren't necessarily lock free.
 Avoid making copies (allocations are slow).
 =std::move= when there is only a copy constructor will do a copy.
*** Categories of "Nastiness" in non-RT Programming
 - Blocking
 - Non-Wait Free: execution time is unbounded (eg. spinlocks)
 - Wait Free: The best. Non unbounded loops or syscalls.
 If sharing data and not interacting with the the RT thread then use locks.
 The optimizer always assumes no data races exist, which can cause strange behaviour (eg. variables cached in register when one thread reads and the other writes).
 Always =static_assert= that =std::atomic::is_always_lock_free= otherwise it is using locks.
 =std::memory_order= can be used to relax the memory ordering of atomic operations.
 This will only be the case with small data structures.
 A relaxed atomic can be used if you don't care about the effects of variable (eg. a control where you just vaguely want to know what the value is).
 When you're dealing with bigger data you can use a try lock (=try_to_lock=) then branch on whether the lock is available.
 Prefer to use a spinlock since =try_lock= and =unlock= will be wait free (=std::mutex='s =unlock= can be blocking since it involves a syscall).
 Non-RT thread could be blocked for a long time since the scheduler could miss the "window" so only use =try_lock= when not getting the data is OK.
** Real-time 101 Part 2: The Real-time Audio Developer's Toolbox
   :SOURCE:
   :Author:   Fabian Renn-Giles & Dave Rowland
   :Source:   https://www.youtube.com/watch?v=PoZAo2Vikbo
   :END:
*** RT thread doesn't modify data
 If the RT thread not changing data then use CAS exchange loop (Compare and Set)
 It gets a =unique_ptr= to the data and atomic pointer to the =unique_ptr=.
 The RT thread gets the pointer from the atomic pointer then sets the atomic ptr to =nullptr=. 
 It then puts it back when it is done.
 The non-RT thread can check if the expected value is in the atomic ptr and then switch values when it is (will be =nullptr= if the RT thread is using the data).
 Farbot has NonRealtimeMutable that does this.
 This can be used if the RT thread can't fail to get the resource.
*** Only RT thread modifies data
Use double buffering where there are two buffers with the RT thread writing into one.
When the non-RT thread wants to read the buffers get swapped so the RT thread can continue writing.
It requires a flag to indicate when there is new data and when it is busy (currently writing).
RealtimeMutable in Farbot since it is difficult to get right.
*** Passing data between threads
Use a FIFO when the data is too large for an atomic.
Since it uses a ring buffer when writing and it is full then can either refuse to write or overwrite the previous data.
Costs of various FIFOs at [27:48].
*** When multiple RT threads and non-RT threads mutating data
Really try to avoid this situation.
Have one thread responsible for mutating the data and the other threads can defer to that one.
*** Debugging Real-time Code
Turn on the thread sanitizer.
=strace=: lists all the system calls of all threads.
*** Summary
- Don't miss deadlines.
- Beware hidden costs.
- Use instrumentation. It's very difficult to reason about RT code.
** Building a Spatial Audio Plug-In
   :SOURCE:
   :Author:   Allen Lee
   :Source:   https://www.youtube.com/watch?v=A7DwT5Aa1dQ
   :END:
The Head Related Impulse Response (HRIR) encodes the Intra-aural Level Difference (ILD) 
and Intra-aural Time Difference (ITD).
The Head Related Transfer Function (HRFT) is the FFT of the HRIR.
Applying the HRTF directly to sounds makes them sound like they are coming from inside
the head.
Room reverberation is important for externalizing the sound.

Spatially Oriented Format for Acoustics (SOFA) is a file format for storing HRIRs (since
they often contain measurements for many different angles).
It also stores the number of measurements and the sampling frequency.

Applying HRTFs can be as easy as applying an FIR filter.
Doing it in the frequency domain can be faster: FFT of input x FFT of HRIR then apply
the inverse FFT.

*Overlap & Add:*
1. Split the signal into N blocks of size M
2. Take the block starting at sample k and perform FFT
3. Do processing
4. Perform inverse FFT
5. Shift the output by k
6. At the end all the blocks are added

*Zero padding*

Changing between HRTFs (moving the sound source) causes noise.
His solution was to process the audio with the old and new HRTFs and then cross-fade the 
results.

Using Constant Overlap and Add (COLA) windowing further reduces artifacts.

He adds reverb to the original signal then mixes it with the binaural sound.
** Interactive Audio Plug-in Development with the Wwise SDK
   :SOURCE:
   :Author:   Joel Robichaud
   :Source:   https://www.youtube.com/watch?v=MOZPi2rtfQo
   :END:
   - interactive as in modified by end user / game player
   - Anatomy of a Wwise plugin
     - two plug-ins: 1 for game engine and other for Authoring tool
       - Authoring plugin:
         - XML descriptor & dll for windows
         - XML describes plugin & editable properties: UI can be autogenerated from this
         - Done by implementing and extending a Wwise C++ object
         - Plug-ins allocate their own memory and register when the dll is attached
       - Sound Engine plug-in:
         - static library (though on Unity it uses a shared object)
         - contains all the DSP
         - several types of plug-ins (effect, sink, ...)
     - Soundbanks are used to communicate between the Authoring and sound engine plug-ins
       - either entirely in memory during development or as a binary file in production
     - Sound Engine must allocate using SDK provided allocators
     - Plug-in generator to ease supporting platforms
       - WWise has a large number of platforms that it supports (all the consoles)
       - CLI tools written in python
       - Generate project based on provided plug-in type
       - Does both Sound Engine & Authoring plugins
       - Premake takes target platform [seems like cmake]
       - The generated plug-in is fully compilable
       - The plug-in is built into the WWise install folder so it will appear in the Authoring tool automatically
       - Finally it packages up all the platforms into an archive
     - Not all JUCE DSP code can be used in WWise because some consoles don't have full C++ support
     - Showing how to share UI code between WWise & JUCE
       - uses multiple inheritance to inherit from both JUCE & WWise
     - possible to build for JUCE with the Wwise build tools
   - On [[https://www.github.com/joelrobichaud/Voluminous][github]] 
** Under the Hood of VST2, VST3, AU, AUv3 and AAX
   :SOURCE:
   :Author:   Fabian Renn-Giles
   :Source:   https://www.youtube.com/watch?v=swVqdbhfkkE
   :END:
 - The guts of the SDKs are huge
 - Why so complicated: just move processing function into dll
   - performance will tank because the compiler can't inline
   - portability fails
 - Windows dlls don't allow dependencies in the host
*** VST2
 - plugins include .cpp file that contains entry point (using C calling convention)
   - sets up dispatcher that sets C++ functions to use
   - kills performance so function pointers passed for performance critical section
 - Simple API for parameters
 - host & plugin can query each others feature support
 - was not intended for multi processor machine
 - problems with ownership of certain things
   - eg. =getSpeakerArrangement= problem with plugin allocating and host deallocating. JUCE just leaks memory here to get it to work correctly on all hosts
 - other limitations of [00:26]
*** Audio Units
 - =ComponentManager= released with Quicktime in 1991
 - Launched 2001 in Mac OSX
 - Divided into scopes: Global, Input, Output
   - Each have elements which have properties
   - Can listen to each property for changes
 - Get given a render callback for audiounits connected to your input and are responsible for calling it to get the input
   - Can get any buffer size from input
   - Allows for more flexibility
 - Have core audio utility classes to overcome portability challenge
 - Features of Parameters [33:34]
 - Parameter changes can be ramped or immediate
 - Addressed many limitations of VST2
*** VST3
 - Structure:
   - Processing part: takes audio & events (DSP only)
   - Controllers does all business logic
   - Controller & processing part only communicate via messages (no pointers)
 - Uses virtual class for communication
   - C++ interfaces are portable across compilers if certain rules are followed (no destructors, only POD parameters, no exceptions, no operators)
   - COM, Avoids opcode system
 - Processor gets parameters from Host
 - Wrappers to export to other plug-in formats
*** AAX
 - Separate controller for business logic & processor which gets audio
 - Almost use COM except use virtual destructors
*** AudioUnits v3
 - Introduced 2013
 - Backwards compatible so same structure as AU
 - Use objective-C which makes it portable
 - Sandboxing
*** The Future
 - Only compile to LLVM byte code that gets compiled by the host
   - SOUL has gone further than this
** Towards std::audio                                                   :cpp:
   :SOURCE:
   :Source:   https://www.youtube.com/watch?v=1aGoJSvwZjg
   :Author:   Guy Somberg & Timur Doumler & Guy Davidson
   :END:
 - creating a simple white noise code requires lots of boiler plate
 - FMOD studio low level api: operate on a DSP graph rather than writing samples
 - Most APIs are either platform specific and proprietary
 - Audio proposal
   - =std::experimatal::audio=
   - can get default device and create callback with =.connect=.
 - plan to standardize interface rather than implementation
 - device: audio input/output endpoint
   - supports callback & polling systems
 - =buffer_list=: all input and output buffers
   - allows for multiple input/output buffers
 - buffer
   - concern over what type to use as different ones used on different systems
 - Channel #sy13-io on cpplang.slack.com
 - SG13-HMI Google Group
** How Perceptual Audio Coding Has Shaped Our Lives
   :SOURCE:
   :Author:   Marina Bosi
   :Source:   https://www.youtube.com/watch?v=3BHMykq5PTU
   :END:
 - Don't waste bits on things that can't be heard
 - Not good at high/low freq but very sensitive to mids
 - Sounds can be masked by other sounds
   - loud sounds mask in freq & time
   - masks before as well (there's a build up and ramps down) Perceptual audio normally treats it as a snapshot and ignores the ramping
 - SMR: Signal to Masked Ratio
 - Take advantage of this to shape quantization noise
 - Have to listen to perceptual codecs to test them
   - look at perceptual differences with original
   - in relation to bitrate
 - thought were done with perceptual coding AAC
   - done with waveform coding
 - SBR (Spectral Band replication) came into play
   - originally applied to speech
   - when encoding a signal and allocating bits, it's safe bet to start allocating bits in the middle of the spectrum
   - if start running out of bits just low pass it
   - Instead chop off high part of spectrum and only encode low part
   - Then derive higher part of the spectrum as a function of the lower part
   - SBR chop off higher part of spectrum
     - Then can transpose lower part of spectrum into the higher part and reshape it
     - That way only need the envelope info for the higher part
     - Saves huge amount of data
 - Stockhausen created 3D (Spherical Concert Hall) installation with 50 speakers in a sphere
   - special compositions were played
** An Introduction to Rust for Audio Developers                        :rust:
   :PROPERTIES:
   :Author:   Ian Hobson
   :Source:   https://www.youtube.com/watch?v=Yom9E-67bdI
   :END:
 - offers low level control with high level abstractions
 - precise timing
 - 2006 started as internal project at Mozilla
 - What makes different to C++?
   - everything const by default
   - choose between 1 mutable reference or \infin immutable references
     - makes concurrency easier to write
 - rustup.rs to install toolchain easy
 - Freeverb: public domain reverb algorithm
   - analysis: ccrma.standrod.edu/~jos/pasp/Freeverb.html
   - binaries and source code available
 - don't have constructors in rust?
 - =unsafe= keyword for dealing with unsafe C FFI
 - using Rust in C++
   - build static/dynamic library
   - add attributes to functions to expose them in C compatible way (=no_mangle, extern=)
   - =cbindgen=: tool to generate a C header from Rust code
   - can then be used in JUCE
 - toolchain for generating WASM
   - =wasmbindgen= to expose Rust code to javascript
 - SIMD is part of standard library
 - Incomplete iOS support
 - Can debug in VSCode
 - [[https://github.com/RustAudio/vst-rs][rust-vst]]
** SOUL Announcement - Keynote ADC 2018
   :SOURCE:
   :Source:   https://www.youtube.com/watch?v=-GhleKNaPdk
   :Author:   Julian Storer
   :END:
 - Audio programming hasn't really changed in 20 years
 - Tools are either fast or easy
   - Tools like PD for prototyping
   - But C++ for production
 - Audio code runs on CPU
   - long way from where audio is used
   - lots of overhead with OS and DAW
   - results in high latency
 - Domain Specific Architecture:
   - have hardware designed for specific task (GPUs, TPUs)
   - DSP is a DSA for audio and they are everywhere. But very difficult to get code to run on it.
   - in comparison: easy to run code on GPU
 - New language: SOUL
   - not a general purpose: designed to augment
   - embedded in existing language
 - SOUL platform:
   - write app in favourite language and call the SOUL API
     - Several options:
       - JIT compiler for SOUL and connect standard audio driver. Was using LLVM JIT for demo
       - Have JIT compiler in driver: avoid passing buffers around. Greater speeds in latency. When running multiple apps call code compiled in to single app.
       - Run code on DSP. Latency close to 0. Hardware already exists
       - Push out of host machines on to separate processor. (smart speaker, rack). Build with server model and ran on Bela board
       - Run in JavaScript to compile to Web assembly using Web audio
   - original programmer doesn't need to know where code would be run
 - No buffers, Write components and connect them together in a graph.
** Fifty Shades of Distortion
   :SOURCE:
   :Author:   Ivan Cohen
   :Source:   https://www.youtube.com/watch?v=oIChUOV_0w4
   :END:
 Examples are on the JUCE forum.
 - static waveshapers
   - Often form basic stage in more complex distortion.
   - Add gain before static waveshaper to experiment to get interesting results.
   - Hard clipping: hard limiting. Useful for limiters. Returns output until above threshold.
   - Tanh waveshapers & sigmoids: 'S' shaped curves. More gentle. Lots of difference waveshapes on the Internet.
   - Square waveshaper [7:28]: Very hard. Round input up or down to two values.
   - Fast approximations of functions: Use approximation (like lookup table) instead of CPU hungry functions (like tanh).
   - Foldover algorithms: transfer function can loop (isn't constantly increasing/decreasing) [9:58]
     - Sine: will generate lots of harmonics, drive control will change harmonic generation a lot.
 - Pre & post filter blocks: Place filters before and after the waveshaper.
   - eg. hi-pass before + lo-pass after
   - Interesting results from removing frequencies before the waveshaper and adding them back in afterwards.
     - Might misunderstand that, it might be that you do the inverse afterwards so you might just boost the frequency band in the wet signal if you had attenuated it before the waveshaper.
   - low-pass filter can be used as cheap cabinet simulator.
   - examples of difference filter blocks at [16:44]
 - Dynamic processors: compressors, noise gates...
*** Digital Only
 - Oversampling:
   - aliasing is a concern with distortion as we're generating harmonics
     - peaks end up aliasing and inharmonic
   - doing the distortion processing with higher sample rates allow to reduce aliasing.
   - Bitcrusher: intentionally uses audio artifacts from over/undersamping
     - simplest way to do it is just replace a lot of samples in input sample with 0
 - slew limiter: effect that doesn't allow the waveform to change faster than a certain threshold
*** Analog Modeling
 - Black box modeling:
   - taking impulse response to get linear measurement
     - only works for linear system
   - Dynamic convolution: used to model non-linear system
 - Hysteresis: wave shaper where shape changes depending how sound is moving?

** Wavetable Synthesis 101
   :PROPERTIES:
   :Author:   Robert Bristow-Johnson
   :END:
 - need a static waveform generator that uses circular table of waveform values
   - a phase accumulator for address generation
   - method of interpolating between samples
 - if linear interpolation is used a larger wavetable needed to reduce error
   - smaller wavetable can be archived and then expanded into larger table using high quality interpolation
 - can change waveform with time by mixing finite set of static phase-locked tables
   - each scaled by individual envelopes
 - 1 method is crossfade between wavetables
   - envelope functions overlap so only two are non-zero at a time
   - even though possibly many tables only two are mixed at a time
 - wavetable size should be an integer power of 2 for simple modulo address arithmetic & convenient radiz-2 DFT or FFT [descends into maths of using wavetables for synthesizing quasi-periodic signals]

** Opening the Box: Whitebox Testing of Audio Software
   :SOURCE:
   :Author: Christof Mathies
   :Source: https://www.youtube.com/watch?v=Kvfhu0WDUM4
   :END:
 - Prioritising automatic test cases
   - by business view - which functionality is most important
   - by failure likeliness? Run the tests that fail the most, first. Likely the section they are testing is fragile and most likely to be broken
   - or only run the tests that test the code that has been changed
 - System must be easy to setup & use
 - Things that can cause false positives
   - noise in audio tests, sometimes running tests in different order results in slightly different "background" noise from the application
   - turned off display, update dialog
 - Plugin testing: measure plugin response and take MD5 of output (for when sound should not change at all)
   - measures similarity:
     - Signal A - Signal B < \epsilon (in case of small noise differences)
     - identical/similar FFT spectrum
       - can get spectrum image as failure report
   - measure impulse response on every build with history
   - other measurements for builds
     - amplitude statistics, spectral properties, total harmonic distortion, SNK, phase delay, peag, speech transmission index
 - Adobe Audition supports scripting to end users. See video for details on setting up.
** Additional
   Didn't have any notes but are listed here to make it easier to find later
*** [[https://www.youtube.com/watch?reload=9&v=9kRFK_Z2FRU][Spatial Audio: Showing You What You Already Know]]
    - Without head movement spectral cues are difficult to hear
    - 50ms delay starts to sound like a second sound
    [Really interesting, quite different talk]
      
* Maths
** Math Symbols Explained with Python
   :SOURCE:
   :Author: Amit Chaudhary
   :Source: https://amitness.com/2019/08/math-for-programmers/
   :END:
 - Indexing: x_{i} or x_{ij} for 2d. Takes the ith element of vector (array)
 - Sigma: $\sum_{i=1}^{N}X_{i}$
   - sum all elements in vector x for range 1 to N
 - Average: $\frac{1}{N}\sum_{i=1}^{N}X_{i}$
   - like sigma but divide by number of elements to get the average
 - PI: $\prod_{i=1}^{N}X_{i}$
   - product of all elements in the given range (1\to{}N)
     #+BEGIN_SRC python
     result = 1
     for i in range(N):
       result = result * x[i]
     #+END_SRC
 - Pipe: | can mean different things depending on position
   - Absolute value: |x|
   - Norm of Values: |x| or ||x||
     - Calculable magnitude of a vector.
     - Square each element of array, summing them then take the square root
 - Belongs to: 3 \in X
   - Check if element (3 in example) is in set (X in example)
 - Function: f:X\to{}Y
   - Denotes function that takes domain X and maps it to range Y
   - Several symbols are used instead of X and Y
     - f:R\to{}R means input and output are any real number
     - f:R^{d}\to{}R R^{d} means d-dimensional vector of real numbers (eg. if d=2 then could be x=[1,2] in python)
 Tensors
 - Transpose: X^{T}
   - exchange rows and columns
     [ [1,2,3], [4,5,6] ]
     becomes
     [ [1,4], [2,5], [3,6] ]
 - Element-wise manipulation: z = x \odot y
   - multiply corresponding elements in two tensors (lists in Python)
 - Dot product: xy or x \cdot y
   - gives the sum of the products of corresponding elements of the two sequences of numbers
     #+BEGIN_SRC python
     x = [1,2,3]
     y = [4,5,6]
     dot = sum([i*j for i,j in zip(x,y)])
     #+END_SRC
 - Hat: $\hat{X}$
   - Unit vector. Divide each element by its norm (||x||)
 - Exclamation: x!
   - Factorial of number (multiply every number from 1 to the given number)
* SE
** What Every Programmer Should Know About Memory
   :SOURCE:
   :Author: Ulrich Drepper
   :Source: https://people.freebsd.org/~lstewart/articles/cpumemory.pdf
   :END:

   Memory stored in a cache is tagged so it can be queried. To save
   space not every word is tagged, instead cache lines are loaded and
   the first part of the memory address is used as the tag. The rest
   of the address (lowest bits) are used as an offset into the cache
   line. Dealing with cache lines is beneficial because subsequent
   bits can be accessed in DRAM without selecting a new column or
   row. Selecting columns or rows takes time. This is based on the
   assumption that a program is likely to access nearby memory.

   *Fully associative cache:* each cache line can store any memory
    location. Requires having to compare the tags of every cache line
    with the requested address making it only practical for very small
    caches (a few dozen entries max).

   *Direct mapped cache:* each tag maps directly to one cache
    entry. It's fast but only works well if the addresses used by the
    program are evenly distributed. This is normally not the case so
    some cache lines be heavily used (and evicted) while others would
    be barely used. Each tag mapping directly is the extreme case. It
    can also be that a middle section of the memory address is used to
    select a set which stores a tag (the upper part of the
    address. That tag would be compared to the requested address tag.

   *Set associative cache:* is like direct mapping except there are
    multiple cached values per set. A set returns multiple tags rather
    than just 1. These tags can be compared against the requested tag
    in parallel. Combines the best part of the other schemes, while
    avoiding most of the weaknesses.

   Hyper-threads are effective when both hyper-threads on a processor
   are sharing data, Otherwise the effective caches are halved since
   both hyper-threads will be loading their own data. The processor
   schedules the other hyper-thread when the first one is waiting
   (eg. for memory access). If both are spending most of their time
   waiting for memory then performance is poor.

   Data is transferred to the CPU/cache from main memory in smaller
   chunks than a cache line [paper has example of 64 bits compared to
   64 byte cache line]. Sometimes the desired word of data is in the
   middle or near the end of the cache line meaning if the cache line
   is loaded in order the CPU will have a long wait. A "critical word"
   can be requested, which will retrieve the desired word first then
   load the rest of the cache line into the cache. If the cache line
   has already started being loaded when the CPU requests a word then
   the cache continues being loaded in order and the CPU has to wait.

   *Translation Look-Aside Buffer (TLB):* is a very small cache that
    stores physical page addresses. It's used to convert a virtual
    address to a physical page. The first part of the virtual address
    is used as the tag and the last part is used as an offset.

   A TLB miss means doing a page table walk, which can be expensive.
   The first part of the virtual address is used to navigate page
   tables (hierarchy of directories that store physical
   addresses). The last part of the address is the offset into the
   physical page to get the address.

   When using virtualisation the cost of cache misses is even
   higher. Work on optimizations will be even more beneficial in
   virtualized environments.

*** Cache Optimizations
    It's a waste when data is produced and not immediately consumed
    since it will take up space in the cache and can evict things that
    are still being used. Especially for large data structures where
    before the last element is filled the first element is evicted to
    cache.

    Can use *non-temporal write operations* to write data straight to
    memory without caching. The intrinsics for x86-64 are
    =_mm_stream_*=. Try to work on an entire cache line at once to
    help with performance. Have to issue all instructions sequentially
    to help with this. It works best on large amounts of data. Data
    can be loaded from memory, processed and written straight back.

    *pahole* is a tool to show how structures are layed out in size
     and on the cache line. It shows where empty space is (for
     alignment) and suggests optimizations.

    Try to arrange elements in a structure in the order of how likely
    they are to be accessed. It puts the critical word at the
    beginning of the cache line. For bigger structs arrange each cache
    line sized block accordingly.

    Try accessing elements in the order they are defined in a
    structure.

    Data types have alignment requirements. If an object is not
    aligned as expected reordering isn't worth it.

    SSE instructions normally require memory to be aligned.

    Consider breaking up data structures if only a small part is
    regularly accessed. The unused parts will unnecessarily be loaded
    and occupy cache space meaning fewer objects will fit.

    It's possible for data to use the same set in the cache even if
    the rest of the cache is not used much (sometimes called a
    "conflict miss"). Laying out data at boundaries of powers of 2
    makes this more likely to happen. The L1 cache often uses virtual
    addresses so is under programmer control. If variables that are
    used together are stored together then they are less likely to
    share a set.

    =_mm_prefetch= is a compiler intrinsic to prefetch memory. It has
    an option to load to L1, L2 & L3 caches and to say when data is
    evicted from L1 to save to memory. When analyzing a program check
    the cache misses & add prefetch at the location of many
    misses. Check the prefetch counters in the CPU counters to check
    if it helped. Add to one place at a time.

    A helper thread can be used to prefetch data for the main
    thread. Avoids having complex prefetch code in the main thread. It
    needs to be synced so the helper can't get too far ahead. If it's
    a hyper-thread then it will populate the lowest level cache. This
    is the perfect usecase since they share data and the main thread
    won't have to wait long.

    If multiple threads are modifying multiple variables that are all
    on the same cache line there will be conficts because the whole
    cache line will be passed between processors. Move variables that
    are often written to by multiple threads on to their own cache
    line. Group read/write variables that are normally used together
    into a struct.

    [details on atomics]

    Bus to memory bandwidth can be limiting. Two threads running on
    different cores using the same data set makes data read twice. Set
    the thread affinity so they are run on the same core.

    The opposite situation is also bad, where two threads running on
    the same core using two data sets will exhaust the cache so will
    read from main memory more often. Set the affinity to run on
    different cores.
**** Optimize L1 Instruction Cache
     Code is normally linear so it is easy to prefetch except for
     jumps, which is why CPUs use branch prediction. Instruction
     caches store decoded instructions.

     Reduce the code footprint since smaller code can put less
     pressure on caches. =-Os= optimizes for code size. Optimizing for
     size should be balanced against other optimizations like loop
     unrolling and inlining.

     Inlining functions might be good for the optimizer but if it is
     used in lots of places it will bloat the code size. This will
     mean the cache will have to store the same code multiple times
     and if that causes evictions then the CPU will decode the
     instructions again. If a small function is not inlined it can be
     referenced in the cache and the branch predictor may work out
     that it will be called. It depends how aggressive the
     optimizations would have been if it had been inlined.

     Code should be linear. If an =if= condition is normally false and
     it contains lots of code (or an inlined function) then the cache
     must store lots of unused code that will be jumped over. It is
     better if the contents of the =if= statement are out of the main
     code path so the jump only happens when the (unlikely) =if=
     condition is true.

     =__builtin_expect= says what an expression will normally be. Use
     it with the following macros to indicate the condition of an =if=
     statement.
     #+BEGIN_SRC C++
       #define unlikely(expr) __builtin_expect(!!(expr), 0)
       #define likely(expr) __builtin_expect(!!(expr), 1)

       // Used as:
       if (likely(a>1))
     #+END_SRC
     Then =-freorder-blocks= will reorder the blocks so the unlikely
     block will be outside the main code path (disabled by =-Os= but
     enabled by =-O2=).

     Alignment can have an effect on code. Align:
     - functions with =-falign-functions=N=
     - blocks only reachable by jumps with =-falign-jumps=N=
     - loops with -falign-loops=N (requires padding in the code, can
       have runtime cost).

     If =N= is too high it will waste space on small/little used
     functions.
**** L2+ Caches
     Match the working set sizes to the cache sizes.

     L1 cache size can be hardcoded and optimized for (assume the
     largest). L2 caches can't be.
**** Optimize TLB Usage
     Reduce the number of pages a program uses.

     Reduce the number of higher level directory tables needed which
     makes lookup cheaper.
**** Measurement
     *Oprofile* is a tool for seeing processor counters.
     *pfmon* as well.

    *opannotate* annotates source/assembly with events from the CPU
     counters. The exact positions of events might not be represented
     accurately.

    The OS keeps track of page faults (major & minor). The =time=
    command (not the shell builtin) reports faults. When the program
    starts all pages that are requested will be page fault, the more
    requested the longer startup will take.

    *rusage* provides various resource usages of a process. Position
     of the page fault could be found by repeatedly requesting
     resource info.

    *cachegrind* simulates cache use and allows for specifying
     different cache parameters (size, associativity). *cg_annotate*
     displays output of cachegrind & can annotate source files. It's
     just a simulation so likely to be different to hardware but it
     gives a good impression.

    *massif* measures memory usage (and can show stack usage).

    *memusage* is another tool to measure memory usage. It's part of
     the GNU C library. It's not a simulation so it's faster than
     massif.

     The performance of lots of small allocations could be improved by
     1 large one and then manage memory internally [good use for =pmr=?].
**** Improve Branch Prediction
     [Has source of =likely=/=unlikely= macros in Appendix A that
     check at runtime whether actual decision matches]

     *Program Guided Optimization (PGO):*
     - compile the program with =-fprofile-generate=
     - run tests that represent workflow. The binary profiles which
       branches are taken and outputs the data as files.
     - recompile the program with =-fprofile-use= to optimize based on
       the measured data.
** Introduction to Algorithms
*** Lecture 1
    :SOURCE:
    :Source:   https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=2&t=0s
    :END:
 - algorithms give you language to talk about program behaviour
 - performance is the currency of acquiring things like security, user friendliness
 - permutation: rearrangement
 - Insertion sort:
   - Running time: reliant on several factors
     - input: if already sorted very little  work. If reverse sorted: lots of work
     - input size: more stuff than takes longer
     - want upper bounds on time to provide guarantee to user
 - Kinds of analysis:
   - worst case: $T(n) = max$ time on any input of size n
     - need an assumption of the statistical distribution of inputs
     - common assumption: all inputs are equally likely
   - Best case: easy to check (can check for particular inputs then immediately output result)
 - Asymptotic analysis:
   - ignore machine dependent constants
   - look at growth of running time (instead of the actual running time)
 - Asymptotic Notation
   - \theta notation: drop low order terms
     - ignore leading constants
     - Eg. $3n^3 + 9On^2 - 5n = \theta(n^3)$
       - this is the engineering method of manipulation \theta notation.
   - asymptotically slower algorithms can be useful depending on size of problem.
   - Could be the faster algorithm is only faster when testing with impractically large problem.
** Ring Buffers and Queues
   :SOURCE:
   :Author:   Fabian Giesen
   :Source:   https://fgiesen.wordpress.com/2010/12/14/ring-buffers-and-queues/
   :END:
 - useful for communicating between threads
 - Structure
   - array of data of fixed size
   - unsigned int reader position
   - unsigned int write position
 - Model 1: Just array indices
   - normally used when talking to hardware
   - positions are array indices
   - write by =Elem[WritePos]=x=
   - increment position with =WritePos=(WritePos + 1) % SIZE=
   - if =ReadPos==WritePos= queue is empty
   - else =WritePos-ReadPos= elements left if =WritePos>ReadPos=
   - or =WritePos + SIZE - ReadPos= elements left if =WritePos < ReadPos=
   - blocks writes when =SIZE - 1=elements already present
 - Model 2: Virtual stream
   - positions store distanced travelled instead of array indices
   - writing becomes =Elem[WritePos % SIZE]=x=
   - update index is =WritePos++=
   - make =SIZE= power of 2 makes computation cheap
     - automatically do the right thing if positions overflow
   - number of elements is =WritePos-ReadPos=
   - if =WritePos==ReadPos+SIZE= then queue is full

** Design Patterns for Low Level Real-Time Rendering
   :SOURCE:
   :Author:   Nicolas Guillemot
   :Source:   https://www.youtube.com/watch?v=mdPeXJ0eiGc&t=2495s
   :END:
 - CPU has MMU for accessing RAM
   - allows virtual memory where non-contiguous addresses appear contiguous and swap space
 - GPU has similar MMU and virtual memory
 - MMUs on CPU and GPU can use memory in the other device. Allows data sharing
 - GPU DMA engines: do copy between system and GPU memory very quickly. Doesn't understand virtual memory
 - Integrated Graphics both GPU and CPU share system memory.
 - Command Lists: Commands for the GPU to execute is sent from CPU. Necessary for CPU to order commands since GPU is an in-order processor
   - fence exists to signal GPU progress through commands (allows CPU/GPU synchronization)
 - Descriptors: struct of address & metadata (examples are buffers, textures)
** Render Design
- start with simulation which updates the scene (might be made of cameras, material)
- then read scene and render into buffers, textures, shaders, passes creating GPU commands
- command are sent to the GPU
  - GPU creates swap chain which makes way to display
- Ring Buffers: section of data where first section is written then while something else reads the writing moves to next block of data
  - Handling wrap-around: create virtual offset to pretend that buffer has infinite size
    - so keep incrementing address and make it by the buffer size to get actual address
      =data=buffer[virt_offset &(RING_SIZE -1)];=
    - allow for lock-free allocation by making offset atomic [27:48]

** Clean Code - Optimization
 The six steps for speeding up a program are:
 1) Determine that it's too slow, and prove you do need to optimize.
 2) Identify the slowest code. Target this point.
 3) Test the performance of the optimised target.
 4) Optimize the code.
 5) Test that the optimized code still works (very important).
 6) Test the speed increase and decide what to do next.

** Introduction to A*
   :SOURCE:
   :Source:   www.redblobgames.com/pathfinding/a-star/introduction.html
   :END:
 - graph search algorithms find paths between points (can take into account distance and travel time)
 - the map is represented as a graph
   - made up of locations (nodes) and connections (edges)
   - the found path is made of nodes and edges
 - Many graph search algorithms exist:
   - Breadth First Search:
     - explores equally in all directions
     - useful for path finding, procedural map generation, flow field pathfinding, distance measuring
   - Dykstra's Algorithm: allow path prioritisation
     - Favours lower cost path
   - A*: modification of Dykstra's algorithm.
     - finds path to 1 location. Priority is the path that seems to be leading to the goal.
*** Breadth First Search
 - all above algorithms keep track of expanding ring called frontier.
 - Implement by
   1) Pick and remove location from frontier
   2) Expand it by looking at its neighbours. Any neighbours we haven't visited yet we add to the frontier, and also to the visited set.
 - to find a path just have to keep track of where we came from to get to each node of the frontier.
   - creates breadcrumbs that lead to start
 - this finds path to every point
   - possible to stop when found goal (early exit)
 - When adding movement cost (ie. distance) need to use Dykstra's algorithm
   - also keep track of movement cost while scanning nodes
   - end up visiting location multiple times with different cost so must add it to the path if cost is lower
   - prioritises visiting neighbours based on cost
 - To find path to one location:
   - prioritises visiting neighbours based on distance to the goal
   - Result is Greedy Best First Search
     - this runs faster but does not produce best path
 - A* algorithm works by combining the estimated distance and movement cost to
   - so uses both actual distance from start and estimated distance to goal

** Design Patterns
*** Abstract Factory
 - A parent class that implements a factory interface
   - children of this class are concrete factories which produce objects of the desired type
 - It allows the type of objects being produced to be completely changed. (eg. for different windowing systems)
 - Often implemented where the top level class (the Abstract Factory) is actually a Concrete Factory so can produce objects. This means any children only have to override a subset of functions.
*** Builder
 - Provides a common interface for building types of objects in steps
 - Main difference to Abstract Factory is that Factories construct an object in one step and then return it. A Builder constructs parts as functions are called and the resulting object is retrieved with a particular functions (e.g. getResult())
 - Concrete Builders inherit from the Builder class to provide the actual building implementation
 - The example had a createMaze function which takes a builder and produces a Maze. Different types of mazes were created by passing different concrete builders (all children of a Maze Builder)
   - The createMaze code could remain the same no matter what Maze was being made.
*** Bridge
 - Allows an implementation to be kept separate from its interface
   - this allows the implementation to be changed without recompilation of client code
   - hides the implementation completely from the client. The interface they see is very pure, it requires no implementation details.
   - allows for multiple implementations
 - Implemented by making a class hierarchy for the interface and a separate one for the implementation.
 - Interface often has higher order functions which are implemented in terms of the lower level functions in the implementation.
 - The interface class has a pointer or owns an instance of the Implementation to call
*** Decorator
 - used to change the responsibilities of an object while maintaining the same interface
 - contains the object and passes the data on to it though after performing some processing first
   - e.g. drawing a border around a window
 - Since everything has same interface it can be used where object would be and can stack multiple decorators
 - inheriting from object makes easy to get that interface
*** Facade
 - provides a common interface for a subsystem
   - abstracts multiple classes
 - Makes the system easier to use but doesn't hide the components in case a client has a reason to use them directly
*** Flyweight
 - to be used when a design would use lots of objects but can't due to resource constraints
 - Requires taking state that is intrinsic to the object and making it extrinsic
   - so the state gets passed to the object by the user
   - allows to have shared references to objects
 - example is a document editor where each character is a separate object.
   - instead there is a flyweight pool with an instance of each ASCII letter. Each letter is shared between wherever it is used in the document.
   - it handles its drawing but gets passed its position and font by the user
 - this saves memory but can cause slowdown as state is calculated and lookups are done
*** Mediator
 - for use when have lots of interactions between several objects
 - all these connections means program acts monolithic and is difficult to alter
 - have a mediator object which all the other objects interact with instead
   - serves as hub for program interactions
*** Memento:
 - Captures and stores the internal state of an object
 - The memento is a separate object (class) which is created by the originator (the object being saved), possibly at the request of a third object.
 - Allows state to be restored without violating encapsulation.
*** Observer
 - An object which can subscribe to changes in another object.
 - Observers add themselves to an object and when anything changes in the object it will go through the list of its observers and call notify.
*** State
 - Allow an object to change its behaviour when its internal state changes
 - states are defined by a separate hierarchy of classes, with each having certain behaviour.
 - An object contains an object of one of the state classes and functionality simply calls the functions in the state object.
 - As the object's state changes, the state object is changed to reflect that.
 - it makes changing stat very simple.
*** Strategy
 - Defines a family of algorithms and makes them interchangeable
 - An interface is created with a base class and specializations of the algorithm inherit and implement the interface.
 - This allows the client to just make a call to the algorithm and allows the algorithms to be reused.
*** Template Method
 - Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.
*** Visitor
 - Perform operations on an object
 - Allow for adding new operations without making changes to the object
 - Works by:
   - defining a base visitor class
   - creating concrete visitor classes
   - the base class has functions for each of the objects the visitors will operate on.
   - those objects have a function that takes a visitor. This function calls the relevant function for the object on the passed in visitor. The object provides the this pointer.
   - The visitor can then operate on the object
     
* Lisp
** Debugging Lisp
   :SOURCE:
   :Author: Michael Malis
   :END:
*** Part 2: Inspecting
    :SOURCE:
    :Source:   https://malisper.me/debugging-lisp-part-2-inspecting/
    :END:
 - Run =(declaim (optimize (debug 3)))= to optimize for debugging
 - C-c C-v TAB inspects object at point on the REPL
 - C-C M-t to trace function
   - C-C T to enter the Trace Dialog buffer
   - Shows you objects being passed to function and can be inspected
 - Inspector allows modification of objects from debugger at run-time
*** Part 3: Redefining Classes
    :SOURCE:
    :Source:   https://malisper.me/debugging-lisp-part-3-redefining-classes/
    :END:
 - CLOS normally implemented using the Meta Object Protocol (MOP) which defines CLOS in terms of itself
   - Classes implemented as objects with instance variables (class name, superclass, ...)
 - Get class object with =find-class=
 - =update-instance-for-redefined-class=
   - method that is called when class is redefined
   - Can be used to change the implementation of existing objects
     - For example can take existing slots and modify them to get the equivalent values for the new slots
   - Undefined when the method will be called but is guaranteed to happen before a variable is accessed
*** Part 4: Restarts
    :SOURCE:
    :Source:   https://malisper.me/debugging-lisp-part-4-restarts/
    :END:
 - =handler-case=: like catch in other languages
 - Restarts provide options to the user on how to recover from an error
   - =restart-case=: with options being the switch statements
   - Restarts are triggered with =invoke-restart=
   - The user uses =handler-bind= to choose what happens when an error occurs
*** Part 5: Miscellaneous
    :SOURCE:
    :Source:   https://malisper.me/debugging-lisp-part-5-miscellaneous/
    :END:
 SBCL's trace takes extra arguments:
 - =:break= takes an expression and will start the debugger when it evaluates true
 - =:break-after= to break after the function is called
 - =:print= and =:print-after= to print when/after the function is called
 There are several cross referencing commands:
 - =slime-who-calls= (C-c C-w C-c) to find calls to a function
 - =slime-who-macroexpands= (C-c C-w C-RET) list uses of a macro
 - =slime-who-references= (C-c C-w C-r) list uses of a variable
 In the debugger one can navigate with M-n, M-p.
 This automatically displays the source code for the frame.
** The Complete Idiot's Guide to Common Lisp Packages
   :SOURCE:
   :Author:   Eran Gatt
   :Source:   http://www.flownet.com/gat/packages.pdf
   :END:
   - =import= imports symbols from other package
   - =make-package=
   - =in-package= to switch into a package
   - =make-symbol= to create symbols
     - can produce multiple distinct symbols with the same name
     - symbols created in the reader with ='= are the same if they have the same name
   - the Lisp reader uses =make-symbol= to create symbols but keeps track of which symbols are created so won't produce 2 different ones with the same name
   - A package is a collection of Lisp symbols where no two have the same name
*** Interning
    - adding a symbol to a package is called interning
    - symbols that are not in any package are uninterned & printed with =#:= prefix (technically the prefix is used for symbols without a home package)
    - =import= interns symbol in the current package
    - =unintern= removes symbol from the current package
    - =symbol-name= returns the name of a symbol as a string
    - =find-symbol= takes a string and says if a symbol with that name is already interned
    - =intern= takes a name and returns the symbol, creating it if necessary
*** Which Package
    - current package is named by the global variable =*PACKAGE*=
    - Home packages
      - all symbols keep track of their home package
        - usually the 1st package the symbol was interned in
      - =symbol-package= queries the home package
      - Symbols are exported from package with =EXPORT= (adds it to the exported list)
      - =UNEXPORT= removes symbol from the exported list
      - can use =USE-PACKAGE= to import all the exported symbols from a package (=UNUSE-PACKAGE= is the reverse)
      - exported symbol only need one =:= to access eg. =package:symbol=
    - Shadowing: CL keeps a list of shadowing symbols
      - symbols can be added to that list so that symbols of the same name can be imported from a different packages
      - =SHADOW= adds symbols to the list from the current package
      - =SHADOWING-IMPORT= adds symbols from other packages
      - undo effect of both with =UNINTERN=
    - symbols are entirely part of the Lisp reader not the evaluator
** ASDF 3 or Why Lisp is Now an Acceptable Scripting Language
   :SOURCE:
   :Author:   Francois-Rene Rideau
   :Source:   http://fare.tunes.org/files/asdf3/asdf3-2014.html
   :END:
*** ASDF
    - an in-image build system, so compiles and loads software into the current CL image
      - in contrast C/C++ where build system is separate program
      - means pressure to keep the core minimal since resource use paid for by every program
    - not geared towards large software in modern adversarial multi-user, multi-processor environment
      - old fashioned single friendly user
    - Bundle operations
      - create a single output file for an entire system or collection systems
      - =compile-bundle-op=: bundles all individual outputs from =compile-op= into a single file
      - =load-bundle-op=: loads result of =compile-bundle-op= into system
      - =lib-op=: links into a library all the object files in a system
      - =dll-op=: creates a dynamically loadable library out of them
      - =deliver-asd-op=: can create a bundle from =compile-bundle-op= and an .asd file to deliver system in binary format only
    - =run-program=: run external commands
      - also short hand =run=: run external command with output to lisp standard- & error output
      - =run/nil=: no output
      - =run/s=: return output as string
      - =run/ss=: return output as stripped string
    - Can annotate components with =:if-feature= to only include it if the expression is true (good for checking compiler and compiler features)
*Standalone Executables*
     - =program-op= creates a standalone executable
     - =:entry-point= designates to call after program image is initialized
*** Code evolution in a conservative community
    - syntax in CL controlled via global variables (including =*readtable*=)
      - =named-readtables= helps with syntax control but proper hygiene not enforced by CL
    - writing the article led them to fix bugs and refactor ASDF and cl-launch so advise you should always explain your programs
*** Pathnames
 - CL spec defines pathnames in a way that means not every feature of the OS is accessible
 - =IOLib=: is library with full reimplementation of pathnames
**** Pathname structure
     Pathnames are made up of:
     - host component: is often =nil= on Unix
     - device component: often nil on Unix. Represents device like "c" on Windows
     - directory component: can be =nil= or list of either =:absolute= or =:relative= followed by 
       - words that name subdirectories or
       - =:wild= (matching any subdir) or
       - =:wild-inferiors=: wildcard matching any recursive subdir
     - name component: often a string but can be nil
     - type component: often a string but can be nil
     - version component: can be nil or positive integer (for old filesystems that supported versioning) or =:newest=
**** Logical Pathnames
     - Logical pathname a way to specify pathname under a virtual host that can be different to the physical path to where the file is on the machine
     - virtual host must be setup before logical pathnames can be used
     - allows mapping certain file types to specific locations
     - useful as it allows the same pathname to refer to different places depending on the computer
     - problem is that it requires setup and one has to avoid host names that may be already used by other software
     - logical pathnames are always a bad idea
       - portability nightmare
       - can't reliably name arbitrary files on an arbitrary system
*** 
    - Verbosity is a bad smell, it suggests lack of abstraction, or bad abstractions
** Land of Lisp
   :SOURCE:
   :Author: Conrad Barski
   :ISBN: 9781593272814
   :END:
 - Association list: =((symbol . (list)))=
   - Search for symbol with =assoc=
 - Can use lists of symbols instead of strings. They are easier to manipulate.
 - Dotted lists are lists where the second part of the last =cons= cell contains something other than =nil=
   - Useful for storing pairs because both slots in the =cons= cell contain data
 - Circular lists: can have circular lists by setting =cdr= of last element to the =car= of the list
   - Set =*print-circle*= to =t= before printing (otherwise it gets recursive)
 - Hash tables are like =assoc= lists but with constant look-up time
 - Implementations often optimize for creating small hash tables so when creating a small one there will often be a delay during allocating lots to it while CL allocates more memory
 - =time=
 - =mapc=: like =mapcar= but use it when you only care about the side effects and not about creating a new list
 - =defstruct=: takes a name and then a list of slots. Seems simpler than classes
   - generated functions prepend the slot name with the struct name
 - =map=: generic =mapcar=. Need to provide the type of the sequence to return
 - Type dispatching: choosing which function to call based on the type of the arguments
 - =defmethod=: like =defun= but defines the type of the parameters. Can have multiple methods with the same name but different parameter types.
 - =with-output-to-string=: takes a stream as an argument and redirects everything intended for it to a string
 - =unwind-protect=: sets up code that will be run even if an error is signalled
   - useful for cleaning up resources
 - Memoization: caching the results of functions to speed them up
   - Create a hash table with the function argument as the key
     - With multiple arguments use nested hash tables
   - Then redefine the function symbol to store a memoized version of the function
 - Tail call optimization: if the last thing a function does is call itself then the function can reuse the stack frame
   - Not supported in all CL implementations
   - Can rearrange a function to include a tail call by putting the recursive code in a local function (=labels=)
 - Anaphoric macro: a macro that makes named variables available in the macro body
 - Macros:
   - Be careful of evaluating forms multiple times in the macro (can be done by referencing a input multiple times)
     - Evaluate once and store the result in a variable
   - Use =gensym= for all local bindings. =gensym= should be run at macro expansion time with the result stored in a variable which is evaluated in the rest of the macro
 - Function programming:
   - Functions should only deal with values passed in as parameters and should have no side effects
   - Code with side effects should be kept separate and call functional code to the actual work

** Fun With Lisp: Programming the NES
   :SOURCE:
   :Source:   https://ahefner.livejournal.com/20528.html
   :END:
 - Machine code is just a kind of data
 - Basis of an assembler is:
   - Accumulate an output vector
   - Remember the current assembly position in terms of address space
   - Mapping symbolic names to locations to make self-referential structures
 - His assembler emits bytes into a context
 - Simpler instructions are just functions that output specific bytes into the context
 - More complex instructions have operands and addressing mode
   - Made addressing mode a class
   - Instruction function then checks the type of the addressing mode to select the correct opcode.
     - It actually splits it up more cleverly based on the way the 6502 IA is structured
 - Because it is all in Lisp it allows to build higher-level controls on top
   - Like structure that pads to get the section to an exact number of cycles
   - Looping macros
 - Did audio by a system that combined lists of sound register writes
** Large-Scale Systems Architecture
   :SOURCE:
   :Author:   Jason Gregory
   :Source:   https://www.youtube.com/watch?v=gpINOFQ32o0
   :END:
 - Games before Uncharted 1 were written in Lisp
   - based on C and assembly under the hood
 - live update but still achieved with C++
 - still use scheme for data and real time scripting
   - can define custom syntax
 - most studios use json, XML or custom parser which takes a lot of work to change
   - with Scheme just add macro
 - Rebuilding all the Scheme stuff takes twice as long as rebuilding the entire game
 - Don't have Debug builds but instead have a file which specifies files to be built as Debug:
   - can debug certain systems but game runs fast
 - Follow KIS: simple solution, change only when something becomes a problem
   - but have a plan for the future
** This Old Lisp
   :SOURCE:
   :Author:   R. Matthew Emerson
   :Source:   https://www.youtube.com/watch?v=MgVuqPgKJQc&t=8s
   :END:
 - 1987 Coral Common Lisp by Coral which was acquired by Apple
   - became MCL then sold ported to embedded then released as OpenMCL
 - Alice Hartley
   - MCL got dropped because it couldn't keep up with Apples changes
 - OpenMCL because Clozure CL
 - has threads:
   - hash tables are thread safe
 - Single space compacting GC: goes through and moves all live objects together
   - objects may move so data must be copied when passed to foreign code
 - convenient C FFI. Can call C functions if know it's name
   - has tool to scan C header files and generate S-expression representation
 - uses CCLDoc for documentation which runs on CCL
 - future plans
   - port to 64-bit ARM
   - experimental register allocator
   - new macOS IDE
 - almost all the features of Lisp have been adopted into other languages
 - to_address: gives address of underlying object
   - always gives C style pointer even if given a smart pointer
 - with large overwhelming errors:
   - start with first line and work down until get to own code
 - works with a range of objects
   - including iterators
** Lessons Learned Implementing Common Lisp with LLVM over Six Years
   :SOURCE:
   :Author:   C. Schafmeister
   :Source:   https://www.youtube.com/watch?v=mbdXeRBbgDM
   :END:
 - Creates molecules
 - work to do with evolutionary molecular design
   - start with molecule
   - test it, score it then mutate then repeat
 - CANDO is for doing this
   - has Clasp: CL compiler inside it
 - originally created lisp interpreter in C++ and had template library for exposing C++ functions to it
 - Why Common Lisp?
   - Macros: compile time computing
   - Language standard is timeless
 - Energy efficiency across programming languages paper from Google
 - Not quite as fast as SBCL
 - started implementing CL in interpreter and as soon as macros introduced the performance dropped
 - Cleavir: is a CL compiler written in CL
 - Wrote a compiler for CL that outputs LLVM IR (but is really slow)
   - uses this to compile Cleavir then switches
 - added debug info so can debug CL with lldb & gdb
 - uses C++ exceptions for unwinding the stack
** Lots of Bits of Lisp: Macros
   :SOURCE:
   :Source:   https://www.youtube.com/watch?v=ygKXeLKhiTI
   :END:
 - different types of macros that happen at different stages of compilation: reader macros, symbol macros, regular macros, compiler macros
 - C-c return: Emacs shortcut to expand macro
   - 'g' will refresh the expanded view if code is changed
 - quasiquote (backtick) quotes a form but allows special directives
   - ',' (comma) will unquote (evaluate) a form
   - ',@' will evaluate and splice in the list. The form must evaluate to a list
 - can't use =funcall= with macros
 - macros are evaluated at compile time not runtime (actually think they get evaluated before compile time)
 - start by writing out the code you want generated
   - then can turn it into function that returns code
   - finally make that a macro
 - &body: lambda list keyword equivalent to &rest but tells editor how to indent macro body correctly
 - recompiling a macro won't change the functions that already use it
 - use =gensym= to create temp variable names
 - =symbol-macrolet=: allows specify a symbol and form. The symbol will be replaced with the form.
*** Reader macro: 
 - Used to create new syntax
 - standard way of creating reader macros makes them global
 - named_readtables package provides file local read tables
   - then use =in-readtable= to make defined macro available to the file
 - Compiler macros:
   - =define-compiler-macro=: can have the same name as a function
   -expanding is optional
   - are used to optimisations
   - expanded and used in the same way as regular macros
 - if you can write a piece as a function instead of a macro use a function
   - if you need a macro try to get the macro to call a function to do the actual work

** Lots of Bits of Lisp - CFFI
   :SOURCE:
   :Source:   https://www.youtube.com/watch?v=A5CnYlG7sc8
   :END:
 - CFFI is a library that provides a common interface for different implementations' FFI
 - most data is allocated on the heap
   - can be on the stack but not very explicit
 - =foreign-alloc=: allocate foreign memory
   - provide type for memory
   - this returns a pointer
 - =mem-aref=: read from memory. Provide type to expect
 - set contents of memory with =self= and =mem-aref=:
   #+BEGIN_SRC lisp
   (self (mem-aref variable :type) value)
   #+END_SRC
 - =foreign-type-size=: check size of type
 - type long-long is not implemented by some CL implementations
 - types: int, uint, long, ulong, short, char, pointer, float, double, int8, int32...
 - can see =(:pointer :othertype)= which indicates what the pointer is to. (Just in the docs, CFFI doesn't actually use that)
 - =defctype=: define type (like typedef)
 - =foreign-alloc=: =:count= keyword to get memory for multiple values. Array
 - =mem-aref=: works like dereferencing array. It takes an index as the last argument.
 - =defcstruct=: to define c structs. Works similarly to =defstruct= except it can't define default values
   - create with =(foreign-alloc '(:struct struct-name))=
   - accessing members is similar to lisp classes
     #+BEGIN_SRC lisp
     (foreign-slot-value variable '(:struct structname) 'slotname)
     #+END_SRC
   - helper macro =with-foreign-slots=
 - =defcenum=: define enums
   - takes keywords and automatically converts to and from ints
   - if you specify the int type when accessing you will get the relevant int value
 - =foreign-free=: takes pointer and frees memory
*** Finding libraries
 - there are default locations for library binaries depending on the OS
   - can add locations to the =*foreign-library-directories*= list
 - =define-foreign-library=
   - can list binary file depending on OS
 - =use-foreign-library=: finds defined dynamic library and load it into the system
 - CFFI-C2FFI: reads a C header file and dumps data as a JSON file
 - =autowrap=: program that takes the JSON file and creates the Lisp bindings
 - =defcfun=: define C function
   #+BEGIN_SRC lisp
   (defcfun (cname lispfunctionname)
   (returntype) args*)
   #+END_SRC
 - =foreign-string-alloc=: helper for creating C string
 - =with-foreign-string=: helper for creating string and then freeing at end of scope
 - =with-foreign-object=: assign object and release as end of scope
 - =with-foreign-objects=: like =with-foreign-object= but for multiple objects
 - possible to create translators to convert between lisp types and C types.
* Other Languages
** Rust 101                                                            :rust:
   :SOURCE:
   :Author:   E. Dunham
   :Source:   https://www.youtube.com/watch?v=FMqydRampuo
   :END:
 - Go is a language for sysadmin. Rust for systems programmers.
 - zero cost abstractions
 - Where not good:
   - where large chunks written in other languages
     - are projects to translate between (Corrode for C)
 - Rust channels:
   - Nightly for trying ideas
   - Betas
   - Stable: always backwards compatible
 - Channel to use:
   - stable code should run anywhere
   - use stable as long as possible
 - Crater: tool that finds all public rust code that compiles it with last and next stable
   - any changes in warnings/err is checked
 - Playpens: rust-lang/rust-playpen
   - can choose output LLVM, ASM
 - Rausty: checks signatures
 - Jonathan turner rls: rust language server
 - Rust wants your code to be doing the right things. Attempting to avoid memory issues
   - can write unsafe Rust to get around safety rules
     - if think you need it double check cause otherwise don't
 - Rustfmt: standardize style
 - Clippy: provides recommendations for code improvements
 - scope syntax
   - similar C++ scope lifetime
 - function: =fn name(param)->return type=
   - not returning the correct type causes errors
 - Macros: shorthand for function with variable number of arguments
 - Expressions end with semicolons
 - match statements: like case but goes line by line rather than nested case statements
   - can match range with =...= (ie. =18...20=)
 - Types & Traits: describe characteristics
   - custom types with struct & enums
   - Trait: attributes that several types might have in common. Allow to generalize a functions input & output
 - Ownership: every value has 1 owner at any time. Can be given away
   - owner can only change variable when declared mutable
 - Borrowing: grant temporary access to a value
   - 1 mutable borrow or unlimited immutable borrows
   - a borrow won't outlive the owner's lifetime and is caught at compile time
 - Compiler use different section of memory if a variable is immutable (stack/heap?)
 - Package Management:
   - crates are published and goes into S3
     - can't be taken down but can be marked as "don't use" (so can't break dependencies)
   - use cargo to create project will put things in right place and make it easy to publish
   - adding dependencies: search crates.io
     - add to dependency section of cargo.toml can also pin to version
   - cargo can be given a script on how to build something so can be used to build other languages
 - Improve Rust
   - double check date on any resources
   - Books: Rust book
     - Rustinomicon: right way to write unsafe
     - O'Reilly book: recommendation for systems programmers
     - Podcasts: newrustacean
       - rustyradio
       - this week in rust
     - Practice: Rustlings, rust by example
** Rust: Hack Without Fear                                             :rust:
   :SOURCE:
   :Author:   Niko Matsakis
   :Source:   https://www.youtube.com/watch?v=lO1z-7cuRYI
   :END:
 - aims for safety: no seg-faults, data-races
 - Zero cost abstraction: high level code that compiles to quite efficient
 - Memory safety:
   - Ownership variable can't have an alias and is owned. Can be given on
     - calling function with variable passes ownership to the function. Compiler keeps track of change of ownership.
   - Borrow: two types of borrowing
     - shared_reference (&T): allows sharing, not mutation
       - Mutability isn't binary so things are immutable for periods of time
     - mutable reference (&mut T) allows mutation but not aliasing. When references created variable is in locked state so borrower can make changes but original variable can't be accessed.
 - =this= keyword is explicit

** Carp - A Language for the 21st Century
   :SOURCE:
   :Author:   Veit Heller
   :Source:   https://www.youtube.com/watch?v=BQeG6fXMk28
   :END:
 - Lisp-1, type inferred: means statically types without extra charge compiles to C
 - borrow-checked: no GC at no extra charge
   - don't have to manually manage memory
   - comes from Rust. figures out lifetimes of values
 - has Lisp macros and a C FFI
 - designed for realtime, graphical and games sort of things
 - has modules rather than namespaces
 - has compile time metaprogramming which limits what can be done at runtime
 - early stage with few packages and lack of documentation
 - macro system is untyped so everything is still symbols & lists at macro expansion time

** Julia: To Lisp or Not to Lisp                                      :julia:
   :SOURCE:
   :Author:   Stefan Karpinski
   :Source:   https://www.youtube.com/watch?v=dK3zRXhrFZY
   :END:
 - Numerical languages
   - Matlab: everything is a complex matrix
   - R: allows NA values anywhere. Data frame as basic type
   - Lots of different ones with different specialisations
   - large part of Scheme and C specs are about numerics
 - Julia designed to not make numbers special
   - numeric types are/can be user defined
 - has macro: invoked with @
 - defined lambda =(x->2x^3)=
 - has bit type that specify a size in bits and name of a new type
 - small amount of C/C++ code for the intrinsics
 - =@edit=: opens the thing you're looking at in the editor
 - =@code_llvm=: prints LLVM code of what you're looking at
 - =@code_native=: look at assembly instructions
 - Julia has multiple dispatch
   - for function definitions can have different bodies for different argument types
   - an error is thrown when there is ambiguity
   - since packages can extend the same methods
 - operations +, *, [, ], \ are usually polymorphic in most languages
   - can't be defined in the language normally
 - promote, promote_rule: I think it allows choosing between different types if both are passed as arguments and promotes types up
   - this gets compiled away
 - rationals: 1//2
 - Arrays: a = [1, 2, 3]
   - can check if all elements are of same type or can be promoted to same type and creates array of that type
   - if can't promote then creates Any array (references to boxed types)
 - allows creating immutable types
 - has function esc for macros that sets the contents in the callers context rather than the macros
   - macros not allowed in local scopes
 - Generated function:
   - functions that generates LLVM IR after all types have been determined
** A Ray of Hope: Array Programming for the 21st Century
   :SOURCE:
   :Author: Gilad Bracha
   :Source: https://www.youtube.com/watch?v=x1FoTYnJxeY&feature=youtu.be
   :END:

   In array programming everything is a multidimensional array and all operations are
   applied to the arrays.
   It makes the notation close to the underlying maths and all iteration is implicit.
   APL is the main language for that.

   Speaker is working on ShapeRank as an evolution of array programming.
   Is working on using streams instead of arrays, has some interesting implications
   which are discussed.
   When dealing with static typing the function signatures deal with the size of the arguments
   and the returns.
** A Slice Through the History of Programming Languages
   :SOURCE:
   :Author:  Gilad Bracha
   :Source: [[https://www.youtube.com/watch?v=91fjAbsJdUo]]
   :END:

   [An interesting look at very early computing and why tools are so line oriented]
   [Interesting introduction to APL & comparison to functional programming]

   A lot of functional programming can be "operating" on other
   functions that build up a function which does all the desired work
   before applying that to the data. Rather than several individual
   operations to modify the data bit by bit.
** Additional
   - [[https://www.youtube.com/watch?v=jmRE5pXFi04&feature=youtu.be]["All of this has happened before, and it will all happen again." : Mark Allen]]
* IT
** Nix Pills
*** Pill 3
 - Runtime dependencies of =hello=: =nix-store -q --references `which hello`=
 - List all dependencies: =nix-store -qR `which man`=
 - 'closures' of derivation is list of all its dependencies. Copying all of these to new computer would allow running of the derivation
 - expressions are only evaluated when needed
 - Functions can only take one argument but nests functions instead =a: b: a*b=
   - gets around it by being able to define sets as arguments ={a, b}: a*b= expects a set with the attributes a and b (can't accept a set with anything else)
 - Supports variadic attributes =...= and default values =b ? 2=
 - =import= just imports and parses a .nix file but doesn't inherit scope of importer
 - can pass things to modules by having the module just be a function
   - then importing module returns a function which can have arguments passed to it in the import expression
     #+BEGIN_SRC nix
     # test.nix
     { a, b ? 3, trueMsg ? "yes", falseMsg ? "no" }:
     if a > b
       then builtins.trace trueMsg true
       else builtins.trace falseMsg false
     #+END_SRC
     #+BEGIN_SRC nix
     import ./test.nix { a = 5; trueMsg = "ok"; }
     # passes a set to the module defined above
     #+END_SRC
*** PIll 4
 - derivations describe a package using the =derivation= command
 - Takes a set with the name, builder and system
 - All environment variables for a build are defined in the derivation
 - .nix file gets "compiled" into .drv file which is built (realised) in various ways:
   - =nix-store -r /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv=
*** Pill 8
 - args to =derivation= are added to the environment as environment variables
 - setting buildInputs to a list of packages will create a space separated list of their locations on disc
 - =with= brings things into scope
 To simplify creating common derivations can create a function that takes a attribute set like the what =derivation= takes.
 It defines its own attribute set like the one =derivation= sets then merges it with the one passed in.
 This merged attribute set is passed to =derivation=.
*** Pill 9
 NAR is simple deterministic archive format.
 NAR created with =nix-store --dump= & =nix-store --restore=
 patchelf is a command that can shrink the rpath to remove unneeded runtime dependencies (gcc in the example).
 Check the dependencies of a derivation as there may be unnecessary packages.
*** Pill 10
 nix-shell takes the same nix file used to build a derivation.
 It creates the same environment used to build it and opens a shell.
 The actual builder isn't set so things like the path should be set.
*** Pill 11
 Garbage collector works by having a list of gcroots which are symlinks to live nix store paths.
 Everything not included in gcroots is dead and can be deleted.
 =nix-store -q --roots= queries which GC roots point to a given derivation.
 Running =nix-build= creates a 'result' symlink in the source directory to the built derivation in the store.
 This 'result' symlink is added as a GC root under /nix/var/nix/gcroots/auto (called *indirect GC root*) so derivation won't be garbage collected.
 Can allow to be garbage collected by deleting the 'result' symlink.
 Update with:
 #+BEGIN_SRC nix
 $ nix-channel --update
 $ nix-env -u --always
 $ rm /nix/var/nix/gcroots/auto/*
 $ nix-collect-garbage -d
 #+END_SRC
*** Pill 13
 In previous pill defined derivation with function that takes packages as parameters.
 Ends up with repeating package names in derivation file and calling file.
 The callpackage pattern allows use to pass packages with the same name as the param by default and only specify overrides.
 =builtins.functionargs= creates an attribute set of arguments to given function.
 =builtins.intersectAttrs: returns intersection of two sets using the values from the second set.
 #+BEGIN_SRC nix
 callpackage = set: f: overrides: f ((builtins.intersectAttrs (builtins.functionargs f) set) // overrides)
 #+END_SRC
 This also allows providing a set with overridden parameters.

** TCP/IP Network Administrator
   :SOURCE:
   :Author: Craig Hunt
   :ISBN: 9781449387143
   :END:
TCP/IP is a whole suite of protocols with TCP and IP being the most important.
Can be seen as 4 layers: Application, Transport, Internet & Network Access.
Each has its own set of protocols.
Sent data goes down the layers and received data goes up.
Each layer passes data to the next layer without knowing how the other layers work.
As data gets passed down each layer it adds a header which includes delivery information (a process called encapsulation).

*** Network Access Layer
Handles delivering data to actual devices.
It converts IP addresses to address appropriate for physical network.

*** Internet Layer
Internet Protocol (IP) is the main protocol of this layer.
- Connectionless: meaning it has no handshake to start the connection.
- Unreliable: includes no error detection or recovery code. It relies on other protocols to provide this.
- Packet: block of data which carries the information needed to deliver it (like a letter)
- IP's datagram is in packet format:
  - First 5-6 32-bit words are the header. The default is 5 but has a field that specifies the header length.
- Gateways: devices that switch packets between different physical networks
  - Packets are routed through gateways to get to different networks.
- Different physical networks have different sizes of packet (maximum transmission unit (MTU))
  - Packets get split up when entering a network with a smaller MTU
  - IP protocol manages the splitting & reassembling of packets
- When a packet arrives at its destination it is passed to the transport layer protocol specified in the packet

Internet Control Message Protocol (ICMP): sends data messages for control, error reporting, and information
- Flow control: can stop source sending too many packets
- Detect unreachable host
- Redirecting routes
- Checking remote host: uses Echo Message (ping uses this)

*** Transport Layer
UDP:
- unreliable connectionless protocol
- Good for when data is small so can just resend the entire data set (overhead of creating connection and reliable delivery too high)
- Some applications do their own reliable data delivery techniques so don't need protocol to do it as well

TCP: reliable connection oriented byte stream protocol
- Resends data unless it hears that the data was received OK (data sent with a checksum for verification by receiver)
- Connection is setup before data is sent with a handshake
- Connection ended with 3 way handshake containing "No more data from Sender bit"
- Receiver responds with ACK which says how much data was received and how much more it can receive
  - Doesn't respond to every single data packet
- Responsible for passing data onto correct application designated by a 16 bit port number

*** Application Layer
- Processes that use Transport Layer protocols to deliver data
*** ...
 - IP address are assigned to network interfaces not hosts
   - a host can have multiple IP addresses
 - unicast address - is an address of single host
 - multicast address - addresses groups of systems
 - broadcast address - addresses all the systems on a network
   - a address with all host bits set to 1 is a broadcast address
 - IP address with all host bits 0 signify network itself
 - address/prefix length is shorthand for writing an IP address and its address mask (eg. 172.31.26.32/27 instead of 172.31.26.32 and the mask 255.255.255.224)
 - =route -n= shows the routing table on Linux
 - =route -C= shows the routing cache which is the routes associated with active connections
 - Applications are identified by port numbers (used by transport protocol to pass data)
   - numbers below 1024 are reserved for well-known services
   - from 1024-49151 are registered ports. A registry is maintained but ports are not assigned.
   - 49152-65535 are available for any use
 - Combination of IP address and port number is called a socket.
   - A socket uniquely identifies a network process across the entire Internet.

** 40 Jenkins Features & Plugins You Wish You Knew Before
   :SOURCE:
   :Source:   https://www.youtube.com/watch?v=3dYM0XUrXHc
   :Author:   Joep Weijers
   :END:
 - Swarm Plugin: plugin on nodes to automatically connect to master
 - agent none runs on master in hidden task
   - use agent none for any steps with user input so don't block executors
 - Pipelines stash files:
   - =stash includes: 'file', name:'name'=
   - =unstash 'name'=
   - sends files to master and can retrieve them from different node
 - can create parameters with =parameters= block
   - Are only checked after first run
 - keep pipelines small
 - If can't terminate build - check log as may be a link there (class UI)
 - Can put common code in shared libraries
 - Create View: can create own views in Jenkins
 - Monitor View: Can select jobs to create nice looking board of jobs (Build Monitor?)
 - API: XML/JSON
   - e.g. use API to check colour of jobs in monitor view to set off light if anything is not green
 - stay up to date
 - JNLP use last version of protocol: previous is unsafe

* Additional
Didn't have any notes but are listed here to make it easier to find later
** [[https://ambrevar.xyz/lisp-repl-shell/index.html][A Lisp REPL as My Main Shell]]                                        :lisp:
** [[https://alhassy.github.io/TypedLisp.html][Typed Lisp, A Primer]]                                                :lisp:
** [[https://medium.com/@MartinCracauer/static-type-checking-in-the-programmable-programming-language-lisp-79bb79eb068a][Static type checking in the programmable programming language (Lisp)]] :lisp:
** [[https://www.youtube.com/watch?v=DHx9kv74Mlc&list=WL&index=6&t=0s][Using Locks in Real Time Audio Processing, Safely]]
** [[https://www.youtube.com/watch?v=rHIkrotSwcc][CppCon 2019: Chandler Carruth There Are No Zero-cost Abstractions]]
   Interesting look into the build costs of code generation and runtime costs of unique_ptr.
** [[https://gdcvault.com/play/1026726/The-Audio-Technology-of-Torchlight][The Audio Technology of 'Torchlight 3']]
  Fairly interesting. Talks about a couple of problems he experienced while working on a game and the solutions (which just so happen to be in his book).
  One of these was setting up a mix using importance: different sound sources have different levels in the mix depending on how important they are.
  Importance is done based on weighted summing on things like distance, "drama" (size and power of the enemy, whether they are targetting you).
  Also interesting solution to volumetric sounds (example was how to position the sound source for something like a river where there is an area that is supposed to be producing the sound).
  Goes through some failed methods (such as placing the sound source on the nearest point on the area (doesn't work because the sound source can suddenly jump around)).
  Solution boils down to working out a direction and spread.
** [[https://www.youtube.com/watch?v=v3dz-AKOVL8&list=WL&index=3&t=6s][Allocators: The Good Parts]]
Seemed quite a good overview of allocators as they stand in c++17. 
Though not a great introduction. 
Would probably be good if I had looked into allocators ahead of time but needed more information on how to use them properly. 
** [[https://www.youtube.com/watch?v=tbUCHifyT24][CppCon 2019: Arthur O'Dwyer Back to Basics: Type Erasure]]
   - Type erasure is erasing information about an object's type and only preserving behaviours (negatable, copyable, deletable, etc.).
   - Used by std::function and std::any
   - Allows for making general objects that can be passed around without having to make an instance of a template for each contained object type.
   - Important to remember, type erased types are normally implemented with heap allocation (to store the contained object) and indirection (since actions on the type erased type have to be translated to the contained type)
     - Example translations included a single function and switch statement or a vtable stored with the contained object on the heap
** [[https://media.handmade-seattle.com/tom-forsyth/][The Lifecycle of an Instruction Set]]
** Debug C++ Without Running - Anastasia Kozakova
 [talks about features of IDEs that support showing information]
** [[https://www.youtube.com/watch?v=COEv2kq_Ht8][Unwinding the Stack: C++ Exceptions on Windows]]
* COMMENT local vars
#+BEGIN_SRC emacs-lisp :results silent
  (defun my-org-export-format-drawer (name content)
    (let ((content (mapcar #'string-trim (split-string content "\n"))))
      (concat (cl-reduce (lambda (one two) (concat one (unless (or (string= one "<p>")
                                                                (string= two "") ; To catch the last run
                                                                (string= two "</p>"))
                                                      "<br/>")
                                                two))
                      content))))
  (setq org-html-format-drawer-function 'my-org-export-format-drawer)
  (push '("" "titletoc" nil ("pdflatex")) org-latex-default-packages-alist)
  (org-babel-do-load-languages
  'org-babel-load-languages '((latex . t)))
#+END_SRC
# Local Variables:
# org-use-sub-superscripts: {}
# org-export-with-sub-superscripts: {}
# End:
